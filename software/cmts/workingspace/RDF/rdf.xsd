<schema xmlns="http://www.w3.org/2001/XMLSchema" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"
	targetNamespace="http://www.w3.org/1999/02/22-rdf-syntax-ns#">

	<annotation>
		<documentation>
			<div xmlns="http://www.w3.org/1999/xhtml">
				<h1>XML Schema for RDF</h1>
				<p>$Id: rdf.xsd,v 1.17 2000/08/04 14:37:44 swick Exp $</p>

				<p>
					originally derived from
					<a href="http://www.oasis-open.org/cover/xmlSchemaForRDF.html">Rick J's
						work</a>
					:
				</p>

				<pre>
					From: Rick JELLIFFE &lt;ricko@allette.com.au>
					To: xml-dev@xml.org
					Subject: Re: new public working draft of XML Schema
					Date: Sat, 26 Feb 2000 23:05:20 +0800
</pre>

				<p>
					then modified to match
					<a href="http://www.w3.org/TR/1999/REC-rdf-syntax-19990222/#grammar">the RDF formal grammar</a>
				</p>

				<blockquote>
					<p>
						created 2000-12-25,
						<br />
						Rick Jelliffe,
						<br />
						Academia Sinica Computing Centre.
						<br />
						Thanks to Henry Thompson for help.
					</p>
					<p>
						RDF Specification at
						<a href="http://www.w3.org/TR">W3C</a>
						.
					</p>
				</blockquote>
			</div>
		</documentation>
	</annotation>


	<!-- Top-level of RDF Document -->
	<element name="RDF">
		<complexType content="elementOnly">
			<sequence maxOccurs="unbounded">
				<group ref="rdf:obj" /> <!-- abstract -->
			</sequence>
		</complexType>
	</element>

	<group name="obj">
		<choice>
			<element ref="rdf:typedNode" />
			<group ref="rdf:container" />
		</choice>
	</group>

	<!-- @@check this after doing typednode -->
	<element name="Description" type="rdf:typedNodeType"
		equivClass="rdf:typedNode" />


	<group name="container">
		<!--
			@@ spec says you can subclass this, but that makes parsing depend on
			schema info. Bad.
		-->
		<choice>
			<element ref="rdf:Bag" />
			<element ref="rdf:Seq" />
			<element ref="rdf:Alt" />
		</choice>
	</group>

	<attributeGroup name="idAboutAttrOpt">
		<annotation>
			<documentation
				source="http://www.w3.org/TR/1999/REC-rdf-syntax-19990222/#aboutAttr" />
		</annotation>
		<attributeGroup ref="rdf:aboutAttrOpt" />
		<attributeGroup ref="rdf:idAttrOpt" />
		<!-- @@leave out aboutEachAttr for now -->

	</attributeGroup>

	<attribute name="ID" type="ID" />

	<attributeGroup name="idAttrOpt">
		<attribute name="ID" use='optional' type="ID" />
		<attribute ref="rdf:ID" use='optional' />
	</attributeGroup>

	<attribute name="about" type="uriReference"/>
	<attributeGroup name="aboutAttrOpt">
		<attribute name="about" use='optional' type="uriReference" />
		<attribute ref="rdf:about" use='optional' />
	</attributeGroup>

	<!-- leaving out aboutEachAttr for now @@-->

	<!-- leaving out bagIdAttr @@-->

	<!-- leaving out propAttr @@-->

	<!-- leaving out typeAttr @@-->

	<element name="propertyElt" abstract="true" type="rdf:propertyEltType" />

	<complexType name="propertyEltType" base="rdf:item"
		derivedBy="restriction">
		<annotation>
			<documentation>this is a "union type"; use
				xsi:type in the instance to discriminate between concrete subtypes
    </documentation>
		</annotation>
	</complexType>

	<complexType name="propertyEltValue" content="textOnly"
		base="rdf:propertyEltType" derivedBy="restriction">
		<attributeGroup ref="rdf:idAttrOpt" />
	</complexType>

	<complexType name="propertyEltLiteral" content="mixed"
		base="rdf:propertyEltType" derivedBy="restriction">
		<any minOccurs="0" processContents="skip" />
		<attributeGroup ref="rdf:idAttrOpt" />
		<attributeGroup ref="rdf:parseLiteral" />
	</complexType>

	<complexType name="propertyEltResource" content="elementOnly"
		base="rdf:propertyEltType" derivedBy="restriction">
		<sequence maxOccurs="unbounded">
			<element ref="rdf:propertyElt" /><!--abstract !-->
		</sequence>
	</complexType>

	<complexType name="propertyEltRef" content="empty"
		base="rdf:propertyEltType" derivedBy="restriction">
		<attributeGroup ref="rdf:idRefAttrOpt" />
		<!-- @@leaving out bagIdAttr? -->
		<!-- @@leaving out propAttr* -->
	</complexType>

	<element name="typedNode" abstract="true" type="rdf:typedNodeType" />

	<complexType name="typedNodeType">
		<sequence maxOccurs="unbounded">
			<element ref="rdf:propertyElt" />
		</sequence>
		<attributeGroup ref="rdf:idAboutAttrOpt" />
		<!--@@leaving out bagidattr, propattr -->
	</complexType>

	<attributeGroup name="idRefAttrOpt">
		<attributeGroup ref="rdf:idAttrOpt" />
		<attributeGroup ref="rdf:resourceAttrOpt" />
	</attributeGroup>

	<!--@@ can complex types be abstract? or just elements? -->
	<complexType name="value" abstract="true" base="rdf:propertyEltType"
		derivedBy="restriction" />

	<complexType name="valueObj" base="rdf:value" derivedBy="restriction">
		<group ref="rdf:obj" />
	</complexType>

	<complexType name="valueString" base="rdf:value" content="mixed"
		derivedBy="restriction">
		<sequence /> <!-- no subelements -->
	</complexType>

	<attribute name="resource" type="uriReference" />
	<attributeGroup name="resourceAttrOpt">
		<attribute name="resource" use='optional' type="uriReference" />
		<attribute ref="rdf:resource" use='optional' />
	</attributeGroup>

	<attributeGroup name="resourceAttr">
		<!-- @@er... which one to require? -->
		<attribute name="resource" use='optional' type="uriReference" />
		<attribute ref="rdf:resource" use='optional' />
	</attributeGroup>

	<element name="Seq" type="rdf:members" />
	<element name="Bag" type="rdf:members" />
	<element name="Alt" type="rdf:members" />
	<!-- @@restrict Alt to have at least one member -->

	<simpleType name="uriReference">
		<restriction base="string"/>
	</simpleType>
	
	<complexType name="members" content="elementOnly">
		<sequence maxOccurs="unbounded">
			<element name="li" type="rdf:item" />
		</sequence>
		<attributeGroup ref="rdf:idAttrOpt" />
		<!-- @@leaving out memberAttr* -->
	</complexType>

	<complexType name="item">
		<annotation>
			<documentation>this is a "union type"; use
				xsi:type in the instance to discriminate between concrete subtypes.
				@@hmm... can I mark this as "abstract" somehow?
    </documentation>
		</annotation>
	</complexType>

	<complexType name="referencedItem" base="rdf:item" content="empty"
		derivedBy="restriction">
		<attributeGroup ref="rdf:resourceAttr" />
	</complexType>

	<!--
		@@strictly speaking, inlineItem should be specified as subtypes, one
		of propertyEltValue, propertyEltLiteral, and propertyEltResource, with
		use="prohibited" on some attributes to get rid of them. But I'm gonna
		skip it for now
	-->

	<attribute name="parseType" />
	<attributeGroup name="parseLiteral">
		<attribute name="parseType" use='required' value="Literal" />
		<attribute ref="rdf:parseType" use='required' value="Literal" />
	</attributeGroup>

	<attributeGroup name="parseResource">
		<attribute name="parseType" use='required' value="Resource" />
		<attribute ref="rdf:parseType" use='required' value="Resource" />
	</attributeGroup>

	<!--
		so much for syntax structure. Now for the particular properties and
		classes...
	-->

	<element name="Statement" type="rdf:typedNodeType" equivClass="rdf:typedNode" />

	<element name="Property" type="rdf:typedNodeType" equivClass="rdf:typedNode" />

	<!--
		these are is constrained to use resource="..."; use xsi:type to do
		something else
	-->
	<element name="subject" type="rdf:propertyEltRef" equivClass="rdf:propertyElt" />

	<element name="predicate" type="rdf:propertyEltRef" equivClass="rdf:propertyElt" />

	<element name="object" type="rdf:propertyEltRef" equivClass="rdf:propertyElt" />

	<element name="type" type="rdf:propertyEltRef" equivClass="rdf:propertyElt" />

	<!-- constrained to the <value>...</value> syntax -->
	<element name="value" type="rdf:valueString" equivClass="rdf:propertyElt" />

</schema>
