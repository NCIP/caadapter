<?xml version="1.0" encoding="UTF-8"?>
<!--
/*******************************************************************************
 * Copyright (c) 2009 Health Level Seven, Inc.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution, and is available at 
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Health Level Seven, Inc. - initial design and content
 *******************************************************************************/ 				
				--><mif:datatypeModelLibrary xmlns:mif="urn:hl7-org:v3/mif2" packageKind="version" name="2.0"
                          title="Data Types - Abstract Specification"
                          schemaVersion="2.1.2">
   <mif:packageLocation combinedId="DEFN=UV=DT=2.0" root="DEFN" artifact="DT" realmNamespace="UV"
                        version="2.0"/>
   <mif:header>
      <mif:approvalInfo approvalStatus="Membership Ballot - Normative" ballotOccurrence="4"/>
   </mif:header>
   <mif:importedVocabularyModelPackage combinedId="DEFN=UV=VO" root="DEFN" realmNamespace="UV" artifact="VO"/>
   <mif:datatype name="ANY" title="DataValue" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:property name="dataType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x) where x.nonNull {
   x.dataType.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x) 
  where x.nullFlavor.implies("INV") {
   x.dataType.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="nullFlavor" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x) {
   x.nullFlavor.isNull.equal(x.nonNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x) {
  x.nullFlavor.implies(NullFlavor.PINF).implies(x.dataType.implies(QTY));
  x.nullFlavor.implies(NullFlavor.NINF).implies(x.dataType.implies(QTY));
  x.nullFlavor.implies(NullFlavor.QS).implies(x.dataType.implies(QTY));
  x.nullFlavor.implies(NullFlavor.TRC).implies(x.dataType.implies(QTY));

  /* if whatever type x is doesn't have an originalText property, 
     the invariant will be null (not true) */
  x.nullFlavor.equals(UNC).implies(((x.dataType)x).originalText.nonNull);

  x.nullFlavor.equals(DER).implies(x.dataType.implies(EXPR&lt;QTY&gt;)
    .and((EXPR&lt;QTY&gt;) x).expression.nonNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="NullFlavor"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="nonNull" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x) {
   x.nonNull.equal(x.isNull.not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BN"/>
      </mif:property>
      <mif:property name="isNull" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x) {
   x.isNull.equal(x.nullFlavor.implies(NullFlavor.NI));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BN"/>
      </mif:property>
      <mif:property name="notApplicable" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x) {
   x.notApplicable.equal(x.nullFlavor.implies(NullFlavor.NA));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="unknown" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x) {
   x.unknown.equal(x.nullFlavor.implies(NullFlavor.UNK));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="other" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x) {
   x.other.equal(x.nullFlavor.implies(NullFlavor.OTH));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="equal" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   x.equal(x);                                         /* reflexivity */
   x.equal(y).equal(y.equal(x));                       /* symmetry */
   x.equal(y).and(y.equal(z)).implies(x.equal(z));      /* transitivity */
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="identical" sortKey="09" propertyKind="variableProperty"
                    visibility="protected"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ANY x, y, z) {
   x.identical(x);                                              /* reflexivity */
   x.identical(y).equal(y.identical(x));                        /* symmetry */
   x.identical(y).and(y.identical(z)).implies(x.identical(z));  /* transitivity */
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BN"/>
      </mif:property>
      <mif:property name="updateMode" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
   CS  updateMode; 
</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="HL7UpdateMode"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="flavorId" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
   SET&lt;ST.SIMPLE&gt;  flavorId;
</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="SET">
            <mif:argumentDatatype name="ST.SIMPLE"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TYPE" title="DataType" datatypeKind="Definition" visibility="private">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:property name="shortName" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(DataType x)
      where x.nonNull {
   x.shortName.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="longName" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="equal" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(DataType x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.shortName.equal(y.shortName));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="TYPE"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="implies" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:parameter name="that" sortKey="1">
            <mif:type name="TYPE"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="isComparableTo" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:parameter name="that" sortKey="1">
            <mif:type name="TYPE"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="BL" title="Boolean" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:enumerationValue>true</mif:enumerationValue>
      <mif:enumerationValue>false</mif:enumerationValue>
      <mif:property name="not" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BL x) {
   true.not.equal(false);
   false.not.equal(true);
   x.isNull.equal(x.not.isNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="and" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BL x, y) {
   x.and(true).equal(x);
   x.and(false).equal(false);
   x.isNull.implies(x.and(y).isNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="or" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BL x, y) {
   x.or(y).equal(x.not.and(y.not).not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="xor" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BL x, y) {
   x.xor(y).equal(x.or(y).and(x.and(y).not));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="equal" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BL x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.equal(true).and(y.equal(true).or(x.equal(false).and(y.equal(false)))));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="implies" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BL condition, conclusion) {
   condition.implies(conclusion).equal(
      condition.not.or(conclusion));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="literal" sortKey="07" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="COLL" title="Collection" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="isEmpty" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="notEmpty" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="count" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="contains" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:parameter name="item" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="BAG" title="Bag" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="COLL"/>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="count" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BAG&lt;T&gt; bag, INT zero)
      where bag.nonNull.and(zero.isZero) {
   bag.isEmpty.equal(bag.count.isZero);
   bag.notEmpty.equal(bag.count.greaterThan(zero));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="COLL"/>
         </mif:derivedFrom>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="count" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BAG&lt;T&gt; bag, T item)
      where bag.nonNull {
   bag.count(item).nonNegative;
   bag.isEmpty.implies(bag.count(item).isZero);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="item" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="contains" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BAG&lt;T&gt; bag, T item)
      where bag.nonNull {
   bag.contains(item).equal(bag.count(item).isNegative.not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="COLL"/>
         </mif:derivedFrom>
         <mif:parameter name="item" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="isEmpty" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BAG&lt;T&gt; bag)
      where bag.nonNull {
   bag.isEmpty.equal(notEmpty.not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="COLL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="notEmpty" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BAG&lt;T&gt; bag)
      where bag.nonNull {
   bag.notEmpty.equal(exists(T item) {
      bag.contains(item);
      });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="COLL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="plus" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BAG&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.plus(y).equal(z).equal(
      forall(T e)
            where e.nonNull {
         z.contains(e).equal(x.contains(e)
                      .or(y.contains(e)));
         });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BAG">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BAG">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="minus" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BAG&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.minus(y).equal(z).equal(
      forall(T e)
            where e.nonNull {
               exists(INT n)
                  where n.equal(x.count(e).minus(y.count(e))) {
         n.nonNegative.equal(z.count(e));
         n.isNegative.equal(z.count(e).isZero);
         };
      });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BAG">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BAG">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="literal" sortKey="08" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
BAG&lt;T&gt;.literal ST.SIMPLE {
   BAG&lt;T&gt;          : "{" elements "}"   { $.equal($2); };
   BAG&lt;T&gt; elements : elements ";" T     { $.except($2).equal($1); }
                  | T                   { $.contains($1);
                                          $.except($1).isEmpty; };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="promotion" sortKey="09" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(T x) {
   ((BAG&lt;T&gt;)x).count.equal(1);
}

invariant(T x) where x.isNull {
   ((BAG&lt;T&gt;)x).count(x).isNull;
}

invariant(T x) where x.nonNull {
   ((BAG&lt;T&gt;)x).count(x).equal(1);
   
   forall(T y) where y.nonNull {
      ((BAG&lt;T&gt;)x).count(y).isZero.not
                 .implies(x.equal(y)) };
}

invariant(T x) where x.isNull {
   ((BAG&lt;T&gt;)x).count(x).unknown;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BAG">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="promotion" sortKey="10" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(DSET&lt;T&gt; x) where x.nonNull {
   ((BAG&lt;T&gt;)x).count.equal(x.count);
};

invariant(DSET&lt;T&gt; x, T y) where x.nonNull.and(y.nonNull) {
   ((BAG&lt;T&gt;)x).contains(y).equal(x.contains(y));
};
</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="DSET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BAG">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="11" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BAG&lt;T&gt; x, BAG&lt;U&gt; y)
      where x.nonNull.and(y.nonNull).and(T.datatype.compares(U.datatype)) {
   x.equal(y).equal((forall(T e) {
      x.count(e).equal(y.count(e));
    }).and(forall(U e) {
      x.count(e).equal(y.count(e));
    }));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="LIST" title="Sequence" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="COLL"/>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="head" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="tail" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:type name="LIST">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="isEmpty" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; x)
      where x.isEmpty {
   x.length.isZero;
   x.head.isNull;
   x.tail.isEmpty;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="COLL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="notEmpty" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; x)
      where x.nonNull {
   x.notEmpty.equal(x.isEmpty.not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="COLL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="item" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; list; INT index)
      where list.nonNull.and(index.nonNegative) {
   list.isEmpty.implies(list.item(index).isNull);
   list.notEmpty.and(index.isZero)
       .implies(list.item(index).equal(list.head));
   list.notEmpty.and(index.nonZero)
       .implies(list.item(index).equal(
          list.tail.item(index.predecessor)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="index" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="contains" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; list; T item)
      where list.nonNull {
   list.isEmpty.implies(list.contains(item).not);
   
   list.nonEmpty.and(item.nonNull).implies(list.contains(item).equal(
        list.head.equal(item).or(list.tail.contains(item))));
		
   list.notEmpty.and(item.isNull).implies(list.contains(item).equal(
        list.head.isNull.or(list.tail.contains(item))));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="COLL"/>
         </mif:derivedFrom>
         <mif:parameter name="item" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="length" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; list)
      where list.nonNull {
   list.isEmpty.equal(list.length.isZero);
   list.notEmpty.equal(list.length.equal(list.tail.length.successor));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="count" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; list) where list.nonNull {
   list.count.equal(list.length);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="COLL"/>
         </mif:derivedFrom>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="subList" sortKey="09" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; x, INT start, end)
   where 
     x.nonNull.and(
	 start.greaterOrEqual(0)).and(
	 start.lessThan(x.length)).and(
	 end.greaterOrEqual(0)).and(
	 end.lessThan(x.length)).and(
	 start.lessOrEqual(end)) {
   x.subList(start, end).length.equal(end.minus(start).sucessor);
   forall(INT i) where i.greaterOrEqual(0).and(i.lessThen(end.minus(start))) {
     x.subList(start, end).item(i).equal(x.item(start.plus(i)));
   }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="start" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:parameter name="end" sortKey="2">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="LIST">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="subList" sortKey="10" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; x, INT start)
   where 
     x.nonNull.and(
	 start.greaterOrEqual(0)).and(
	 start.lessThan(x.length)).and(
	 end.greaterOrEqual(0)) {
   x.subList(start).length.equal(x.length.minus(start));
   forall(INT i) where i.greaterOrEqual(0) {
     x.subList(start).item(i).equal(x.item(start.plus(i)));
   }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="start" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="LIST">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="11" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; x, LIST&lt;U&gt; y)
      where x.nonNull.and(y.nonNull).and(T.datatype.compares(U.datatype)) {
   x.isEmpty.and(y.isEmpty).implies(x.equal(y));
   
   (x.notEmpty.and(y.isEmpty)).or(x.isEmpty.and(y.notEmpty)).implies(x.equal(y).not);
   
   x.notEmpty.and(y.notEmpty).and(x.head.nonNull).implies(
      x.equal(y).equal(x.head.equal(y.head).and(x.tail.equal(y.tail))));
	  
   x.notEmpty.and(y.notEmpty).and(x.head.isNull).implies(
      x.equal(y).equal(y.head.isNull.and(x.tail.equal(y.tail))));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="literal" sortKey="12" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
LIST&lt;T&gt;.literal ST.SIMPLE {
   LIST&lt;T&gt; : "(" elements ")"        { $.equal($2); }
           | "(" ")"                 { $.isEmpty; };
   LIST&lt;T&gt; elements
           : T ";" elements          { $.head.equal($1);
                                       $.tail.equal($3); }
           | T                       { $.head.equal($1);
                                       $.tail.isEmpty; };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="promotion" sortKey="13" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(T x) {
   ((LIST&lt;T&gt;)x).head.equal(x);
   ((LIST&lt;T&gt;)x).tail.isEmpty;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="LIST">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="demotion" sortKey="14" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(LIST&lt;T&gt; x) where x.nonNull {
   ((BAG&lt;T&gt;)x).count.equal(x.count);
};

invariant(LIST&lt;T&gt; x, T y) where x.nonNull.and(y.nonNull) {
   ((BAG&lt;T&gt;)x).contains(y).equal(x.contains(y));
};
</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BAG">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="SET" title="Set" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:parameter name="C" sortKey="2">
         <mif:type name="COMP"/>
         <mif:defaultValue name="CEQ"/>
      </mif:parameter>
      <mif:property name="comparator" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; x)
      where x.nonNull {
 forall(T a) where a.nonNull {
   forall(T b) where b.nonNull {
     /* if the comparator cannot compare a or b,
	    both cannot be in the Set */ 
	 x.contains(a).and(x.contains(b)).implies.
	    x.comparator.compare(a, b).nonNull;  
	   
     /* if both a and b are in the set, they must be different 
       (unless they are the are the same instance)*/ 
	 x.contains(a).and(x.contains(b)).implies(
	   a.identical(b).or(x.comparator.compare(a, b).not));
	 }
   }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="C">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="contains" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage"/>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="element" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="contains" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; superset, subset) 
      where superset.nonNull.and(subset.nonNull) {
         superset.contains(subset).equal(
      forall(T element) where subset.contains(element) {
         superset.contains(element);      
	     });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="subset" sortKey="1">
            <mif:type name="SET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="isEmpty" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; set)
      where set.nonNull {
   set.isEmpty.equal(notEmpty.not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="notEmpty" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; set)
      where set.nonNull {
   set.notEmpty.equal(exists(T element) {
      set.contains(element);
      });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="cardinality" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; set)
      where set.nonNull {
   exists(T element) where set.contains(element) {
      set.cardinality.equal(set.except(element)
                     .cardinality.successor);
         };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="union" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   x.union(y).equal(z).equal(forall(T e) {
      z.contains(e).equal(x.contains(e).or(y.contains(e)));
      });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="otherset" sortKey="1">
            <mif:type name="SET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="union" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; set, singletonset; T element)
      where set.nonNull.and(element.nonNull)
               .and(singletonset.cardinality.isOne)
               .and(singletonset.contains(element)) {
   set.union(element).equal(set.union(singleton));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="element" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="except" sortKey="09" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   x.except(y).equal(z).equal(forall(T e) {
      z.contains(e).equal(x.contains(e).and(y.contains(e).not));
      });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="otherset" sortKey="1">
            <mif:type name="SET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="except" sortKey="10" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; x, z; T d)
      where x.nonNull.and(z.nonNull).and(d.nonNull) {
   x.except(d).equal(z).equal(forall(T e) {
      z.contains(e).equal(x.contains(e).and(d.equal(e).not));
      });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="element" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="intersection" sortKey="11" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   x.intersection(y).equal(z).equal(forall(T e) {
      z.contains(e).equal(x.contains(e).and(y.contains(e)));
      });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="otherset" sortKey="1">
            <mif:type name="SET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="12" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; x, SET&lt;U&gt; y)
      where x.nonNull.and(y.nonNull).and(T.datatype.compares(U.datatype)) {
   x.equal(y).equal((forall(T e) {
      x.contains(e).equal(y.contains(e));
    }).and(forall(U e) {
      x.contains(e).equal(y.contains(e));
    }));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="SET"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="COMP" title="Comparator" isAbstract="true" datatypeKind="Definition"
                 visibility="protected">
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
type MyTelephoneComparator alias MYTELCOMP specializes COMP&lt;TEL&gt;{
    BL      compare(T element1, T element2);
};

invariant(MYTELCOMP c, TEL x, y)
      where x.equal(y).nonNull {
   c.compare(x, y).equal(
     x.equal(y)
      .and(x.useablePeriod.isNull.xor(y.useablePeriod.isNull)).not
	  .or(x.useablePeriod.nonNull.implies(
	     x.useablePeriod.equals(y.useablePeriod))));
};
</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="dataType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(COMP x) {
   x.dataType.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="compare" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(COMP&lt;T&gt; c, T x, y, z)
      where x.nonNull.and(y.nonNull).and(z.nonNull) {
   c.compare(x, x);                                                 /* reflexivity */
   c.compare(x, y).equal(c.compare(y, x));                          /* symmetry */
   c.compare(x, y).and(c.compare(y, z)).implies(c.compare(x, z));   /* transitivity */
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="element1" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:parameter name="element2" sortKey="2">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CEQ" title="EqualComparator" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="COMP"/>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="compare" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CEQ&lt;T&gt; c, T x, y)
      where x.equal(y).nonNull {
   c.compare(x, y).equal(x.equal(y));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="element1" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:parameter name="element2" sortKey="2">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="DSET" title="DiscreteSet" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SET"/>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:parameter name="C" sortKey="2">
         <mif:type name="COMP"/>
      </mif:parameter>
      <mif:property name="count" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(DSET&lt;T&gt; set) where set.nonNull {
   set.count.equal(set.cardinality);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="COLL"/>
         </mif:derivedFrom>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="literal" sortKey="02" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
DSET&lt;T&gt;.literal ST.SIMPLE {
   DSET&lt;T&gt;          : "{" elements "}"   { $.equal($2); };
   DSET&lt;T&gt; elements : elements ";" T     { $.except($2).equal($1); }
                  | T                   { $.contains($1);
                                          $.except($1).isEmpty; };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="promotion" sortKey="03" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(T x) where x.nonNull {
   ((DSET&lt;T&gt;)x).contains(x);
   ((DSET&lt;T&gt;)x).except(x).isEmpty;
};

invariant(T x) where x.isNull {
   ((DSET&lt;T&gt;)x).isNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="DSET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="SET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="HXIT" title="HistoryItem" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="T" qualifier="parameter"/>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="validTime" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(HXIT&lt;T&gt; x) where x.nonNull {
  x.validTime.nonNull.implies(x.validTime.low.nonNull.or(x.validTime.high.nonNull));
  x.validTime.nonNull.implies(x.validTime.width.isZero.not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="IVL">
            <mif:argumentDatatype name="TS"/>
         </mif:type>
      </mif:property>
      <mif:property name="comesBefore" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(HXIT&lt;T&gt; x, y) where x.validTime.nonNull.and(y.validTime.nonNull) {
  x.comesBefore(y).implies(x.validTime.high.nonNull);
  x.comesBefore(y).implies(y.validTime.low.nonNull);
  x.comesBefore(y).implies(x.validTime.high.lessOrEqual(y.validTime.low));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="controlActIdRef" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="II"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="HIST" title="History" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="HXIT">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:argumentDatatype>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(HIST x; HXIT&lt;T&gt; e)
      where x.nonNull {
  x.contains(e).implies(e.validTime.nonNull);

  forall(INT.POSITIVE i) where i.lessThan(x.length) {
      x.item(i.predecessor).comesBefore(x.item(i));
  };
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="current" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="HXIT">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="earliest" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(HIST x; HXIT&lt;T&gt; e)
      where x.contains(e) {
   x.earliest.validTime.low.lessOrEqual(e.validTime.low);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="HXIT">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="exceptEarliest" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(HIST x)
      where x.nonNull {
   x.exceptEarliest.equal(x.except(x.earliest));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="HIST">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="latest" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(HIST x; HXIT&lt;T&gt; e)
      where x.contains(e) {
   x.latest.validTime.high.greaterOrEqual(e.validTime.high);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="HXIT">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="exceptLatest" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(HIST x)
      where x.nonNull {
   x.exceptLatest.equal(x.except(x.latest));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="HIST">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="demotion" sortKey="06" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(HIST x)
      where x.nonNull {
   x.notEmpty;
   ((T)x).equal(x.current);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="HXIT">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="BIN" title="BinaryData" datatypeKind="Definition" visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="BN"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(BIN x)
      where x.nonNull {
   x.notEmpty;
   x.length.greaterThan(0);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="equal" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ED" title="EncapsulatedData" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:property name="data" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ED x)
      where x.nonNull {
   x.data.nonNull;			
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BIN"/>
      </mif:property>
      <mif:property name="mediaType" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="text/plain"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage"/>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="MediaType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="charset" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="Charset"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="language" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="HumanLanguage"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="compression" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CompressionAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="reference" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="TEL.URL"/>
      </mif:property>
      <mif:property name="integrityCheck" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="BIN"/>
      </mif:property>
      <mif:property name="integrityCheckAlgorithm" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="SHA-1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="IntegrityCheckAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="description" sortKey="09" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="thumbnail" sortKey="10" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage"/>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="translation" sortKey="11" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ED x)
      where x.nonNull {
   forall(ED t) where x.translation.contains(t) {
     t.description.isNull;
	 t.language.equals(x.language).not.or(t.mediaType.equals(x.mediaType).not);
	 t.translation.isEmpty;
   }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="DSET">
            <mif:argumentDatatype name="ED"/>
         </mif:type>
      </mif:property>
      <mif:property name="length" sortKey="12" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ED x, INT y)
      where x.nonNull.and(y.isZero) {
   x.length.greaterThan(y);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="subPart" sortKey="13" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:parameter name="start" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:parameter name="end" sortKey="2">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="equal" sortKey="14" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ST" title="CharacterString" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.headCharacter.notEmpty;
   x.headCharacter.length.equal(1);
   x.headCharacter.tailString.isEmpty;
   x.tailString.isEmpty.implies(x.length.equal(1));
   x.tailString.notEmpty.implies(x.length.equal(x.tailString.length.successor));
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="data" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="BIN"/>
      </mif:property>
      <mif:property name="mediaType" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="text/plain"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.mediaType.code.equal("text/plain");
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="MediaType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="charset" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.charset.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="Charset"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="language" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="HumanLanguage"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="compression" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.compression.notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CompressionAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="reference" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.reference.notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="TEL.URL"/>
      </mif:property>
      <mif:property name="integrityCheck" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.integrityCheck.notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="BIN"/>
      </mif:property>
      <mif:property name="integrityCheckAlgorithm" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.integrityCheckAlgorithm.notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="IntegrityCheckAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="thumbnail" sortKey="09" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.thumbnail.notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="headCharacter" sortKey="10" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="ST.NT"/>
      </mif:property>
      <mif:property name="tailString" sortKey="11" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="ST.NT"/>
      </mif:property>
      <mif:property name="translation" sortKey="12" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
   x.translation.dataType.implies(DSET&lt;ST&gt;);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="ST.NT"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="13" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ED"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="literal" sortKey="14" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
ST.literal ST.SIMPLE {
   ST : /"[^]+"/         { $.equal($1); }  /* quoted string */
      | /[a-zA-Z0-9_]+/  { $.equal($1); }; /* token form */
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="SC" title="CharacterStringWithCode" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ST"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SC x)
      where x.nonNull {
   x.code.nonNull.implies(x.notEmpty);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SC x)
      where x.nonNull {
   x.code.nonNull.implies(x.code.originalText.equals(x));
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="code" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CV"/>
      </mif:property>
      <mif:property name="equal" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ED"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="translation" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="ED"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CD" title="ConceptDescriptor" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x)
      where x.nonNull {
   x.code.nonNull.or(x.originalText.nonNull);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="code" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x)
      where x.nonNull {
   x.code.nonNull.or(x.originalText.nonNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="codeSystem" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x)
      where x.code.nonNull {
   x.codeSystem.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x)
      where x.other {
   x.code.other;
   x.codeSystem.nonNull.or(x.valueSet.nonNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="UID"/>
      </mif:property>
      <mif:property name="codeSystemName" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x) {
   x.codeSystemName.nonNull.implies(x.codeSystem.nonNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.NT"/>
      </mif:property>
      <mif:property name="codeSystemVersion" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x) {
   x.codeSystemVersion.nonNull.implies(x.codeSystem.nonNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="valueSet" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="UID"/>
      </mif:property>
      <mif:property name="valueSetVersion" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x)
      where x.valueSet.nonNull {
   x.valueSetVersion.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="displayName" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x) {
   x.displayName.nonNull.implies(x.code.nonNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="originalText" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x) {
  forall(CD translation) where x.translation.contains(translation) {
         translation.originalText.isNull;
         };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ED.TEXT"/>
      </mif:property>
      <mif:property name="codingRationale" sortKey="09" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="SET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CodingRationale"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="translation" sortKey="10" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x) {
  forall(CD t) where x.translation.contains(t) {
         t.translation.isEmpty;
         };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="DSET">
            <mif:argumentDatatype name="CD"/>
         </mif:type>
      </mif:property>
      <mif:property name="source" sortKey="11" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x) where x.nonNull.and(x.source.nonNull) {
  x.translation.contains(x.source).or(x.source.translation.contains(x));
};
</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="CD"/>
      </mif:property>
      <mif:property name="equal" sortKey="12" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CD x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.code.equal(y.code)
             .and(x.codeSystem.equal(y.codingSystem)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="implies" sortKey="13" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:parameter name="x" sortKey="1">
            <mif:type name="CD"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CO" title="CodedOrdinal" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="CD"/>
      </mif:derivedFrom>
      <mif:property name="value" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="equal" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="CD"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="lessOrEqual" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CO x, y)
      where x.nonNull.and(y.nonNull)
	    .and(x.value.nonNull).and(y.value.nonNull) {
   x.lessOrEqual(y).equal(x.value.lessOrEqual(y.value));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="o" sortKey="1">
            <mif:type name="CO"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="lessThan" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CO x, y)
      where x.nonNull.and(y.nonNull) {
   x.lessThan(y).equal(y.lessOrEqual(x).and(x.equal(y).not));
};

invariant(CO x, y)
      where x.nonNull.and(y.nonNull)
	    .and(x.value.nonNull).and(y.value.nonNull) {
   x.lessThan(y).equal(x.value.lessThan(y.value));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="o" sortKey="1">
            <mif:type name="CO"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="greaterThan" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CO x, y)
      where x.nonNull.and(y.nonNull) {
   x.greaterThan(y).equal(y.lessThan(x));
};

invariant(CO x, y)
      where x.nonNull.and(y.nonNull)
	    .and(x.value.nonNull).and(y.value.nonNull) {
   x.greaterThan(y).equal(x.value.greaterThan(y.value));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="o" sortKey="1">
            <mif:type name="CO"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="greaterOrEqual" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CO x, y)
      where x.nonNull.and(y.nonNull) {
   x.greaterOrEqual(y).equal(y.lessOrEqual(x));
};

invariant(CO x, y)
      where x.nonNull.and(y.nonNull)
	    .and(x.value.nonNull).and(y.value.nonNull) {
   x.greaterOrEqual(y).equal(x.value.greaterOrEqual(y.value));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="o" sortKey="1">
            <mif:type name="CO"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CS" title="CodedSimpleValue" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="CV"/>
      </mif:derivedFrom>
      <mif:property name="code" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CS x)
      where x.nonNull {
   x.code.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="codeSystem" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CS x)
      where x.code.nonNull {
   x.codeSystem.nonNull;
   x.codeSystem.equal(CONTEXT.codeSystem);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CS x)
      where x.other {
   x.code.isNull;
   x.codeSystem.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="UID"/>
      </mif:property>
      <mif:property name="codeSystemName" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CS x) {
   x.codeSystemName.equal(CONTEXT.codeSystemName);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST.NT"/>
      </mif:property>
      <mif:property name="codeSystemVersion" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CS x) {
   x.codeSystemVersion.equal(CONTEXT.codeSystemVersion);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="displayName" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CS x) {
   x.displayName.notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="originalText" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CS x) {
   x.originalText.notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ED.TEXT"/>
      </mif:property>
      <mif:property name="equal" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="CD"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="literal" sortKey="08" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
CS.literal ST.SIMPLE {
   CS : /[a-zA-Z0-9_]+/  { $.equal($1); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="UID" title="UniqueIdentifierString" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ST.SIMPLE"/>
      </mif:derivedFrom>
      <mif:property name="equal" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ED"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="OID" title="ObjectIdentifier" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="UID"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(OID x)
      where x.nonNull {
   x.notEmpty;
   x.tail.isEmpty.implies(x.leaf.equal(x.tail));
   x.tail.notEmpty.implies(x.leaf.equal(x.tail.leaf));
   x.tail.isEmpty.implies(x.butLeaf.isNull);
   x.tail.notEmpty.implies(x.butLeaf.head.equal(x.head)
         .and(x.butLeaf.tail.equal(x.butLeaf(x.tail))));
   forall(OID v; OID n) where v.equal(x.value(n)) {
      n.isEmpty.implies(v.equal(x));
      n.notEmpty.implies(v.equal(x.value(n.tail)));
      };
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="leaf" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="butLeaf" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="OID"/>
      </mif:property>
      <mif:property name="value" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:parameter name="namespace" sortKey="1">
            <mif:type name="OID"/>
         </mif:parameter>
         <mif:type name="OID"/>
      </mif:property>
      <mif:property name="literal" sortKey="04" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
OID.literal ST.SIMPLE {
   OID : INT "." OID { $.head.equal($1);
                       $.tail.equal($3); }
       | INT         { $.head.equal($1);
                       $.tail.isEmpty; }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="equal" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ED"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="UUID" title="UniversalUniqueIdentifier" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="UID"/>
      </mif:derivedFrom>
      <mif:property name="timeLow" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="timeMid" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="timeHighAndVersion" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="clockSequence" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="node" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="literal" sortKey="06" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
UUID.literal ST.SIMPLE {
   UUID        : hex8 "-" hex4 "-" hex4 "-" hex4 "-" hex12 {
                    $.timeLow.equal($1);
                    $.timeMid.equal($3);
                    $.timeHighAndVersion.equal($5);
                    $.clockSequence.equal($7);
                    $.node.equal($9);
                    }

   INT hex4    : hexDigit hexDigit hexDigit hexDigit {
                    $.equal($1.times(16).plus($2)
                     .times(16).plus($3)
                     .times(16).plus($4);
                    }

   INT hex8    : hexDigit hexDigit hexDigit hexDigit
                       hexDigit hexDigit hexDigit hexDigit {
                    $.equal($1.times(16).plus($2)
                     .times(16).plus($3)
                     .times(16).plus($4)
                     .times(16).plus($5)
                     .times(16).plus($6)
                     .times(16).plus($7)
                     .times(16).plus($8);
                     }

   INT hex12    : hexDigit hexDigit hexDigit hexDigit
                        hexDigit hexDigit hexDigit hexDigit
                        hexDigit hexDigit hexDigit hexDigit {
                     $.equal($1.times(16).plus($2)
                      .times(16).plus($3)
                      .times(16).plus($4)
                      .times(16).plus($5)
                      .times(16).plus($6)
                      .times(16).plus($7)
                      .times(16).plus($8)
                      .times(16).plus($9)
                      .times(16).plus($10)
                      .times(16).plus($11)
                      .times(16).plus($12);
                     }

   INT hexDigit : "0"     { $.equal(0); }
                | "1"     { $.equal(1); }
                | "2"     { $.equal(2); }
                | "3"     { $.equal(3); }
                | "4"     { $.equal(4); }
                | "5"     { $.equal(5); }
                | "6"     { $.equal(6); }
                | "7"     { $.equal(7); }
                | "8"     { $.equal(8); }
                | "9"     { $.equal(9); }
                | "A"     { $.equal(10); }
                | "B"     { $.equal(11); }
                | "C"     { $.equal(12); }
                | "D"     { $.equal(13); }
                | "E"     { $.equal(14); }
                | "F"     { $.equal(15); }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="equal" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ED"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="RUID" title="HL7ReservedIdentifierScheme" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="UID"/>
      </mif:derivedFrom>
      <mif:property name="equal" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ED"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="II" title="InstanceIdentifier" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(II x) {
   root.isNull.and(root.notApplicable.not).implies(x.isNull);
   extension.isNull.and(extension.notApplicable.not).implies(x.isNull);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="root" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(II x)
      where x.nonNull {
   root.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="UID"/>
      </mif:property>
      <mif:property name="extension" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(II x)
      where x.extension.isNull {
   x.notApplicable().not.implies(x.isNull);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="identifierName" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="ST.NT"/>
      </mif:property>
      <mif:property name="scope" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="IdentifierScope"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="reliability" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="IdentifierReliability"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="displayable" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="equal" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(II x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.root.equal(y.root)
             .and(x.extension.notApplicable.and(y.extension.notApplicable).or(x.extension.equal(y.extension))));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="literal" sortKey="08" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
II.literal ST.SIMPLE {
   UID ":" ST { 
      $.root.equal($1).and($.extension.equal($3)); 
   }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="URL" title="UniversalResourceLocator" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:property name="scheme" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="URLScheme"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="address" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="literal" sortKey="03" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
URL.literal ST.SIMPLE {
   URL : /[a-z0-9+.-]+/ ":" ST   { $.scheme.equal($1);
                                   $.address.equal($3); }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
protected type TelephoneURL alias TelURL specializes URL {
   literal ST.SIMPLE {
      URL                 : /(tel)/ ":" address   { $.scheme.equal($1);
                                                          $.address.equal($3); };
      ST address          : "+" phoneDigits
      ST phoneDigits      : digitOrSeparator phoneDigits
                          | digitOrSeparator
      ST digitOrSeparator : digit
                          | separator;
      ST digit            : /[0..9]/;
      ST separator        : /[().-]/;
      };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="canonical" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="URL"/>
      </mif:property>
      <mif:property name="equal" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(URL x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.scheme.equal(y.scheme).and(x.canonical.address.equal(y.address.canonical)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="URL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TEL" title="TelecommunicationAddress" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="URL"/>
      </mif:derivedFrom>
      <mif:property name="use" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:type name="DSET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="TelecommunicationAddressUse"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="capabilities" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:type name="DSET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="TelecommunicationCapabilities"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="useablePeriod" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="GTS"/>
      </mif:property>
      <mif:property name="equal" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ADXP" title="AddressPart" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SC.NT"/>
      </mif:derivedFrom>
      <mif:property name="partType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="AddressPartType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="language" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="HumanLanguage"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="equal" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ADXP x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.partType.equal(y.partType).and(((ED)x).equal((ED)y)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ADXP"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="AD" title="PostalAddress" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="ADXP"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:property name="use" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:type name="DSET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="PostalAddressUse"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="useablePeriod" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="GTS"/>
      </mif:property>
      <mif:property name="isNotOrdered" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="equal" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(AD x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal((
      forall(ADXP p) where x.contains(p) {
	     y.contains(p);
	     }).and(
            forall(ADXP p) where y.contains(p) {
	           x.contains(p);
	           }));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="formatted" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="ST.NT"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ENXP" title="EntityNamePart" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SC.NT"/>
      </mif:derivedFrom>
      <mif:property name="partType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="EntityNamePartType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="qualifier" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:type name="DSET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="EntityNamePartQualifier"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="language" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ENXP x) {
   x.language.notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="HumanLanguage"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="equal" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ENXP x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.partType.equal(y.partType).and(((ED)x).equal((ED)y)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ADXP"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="EN" title="EntityName" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="LIST">
            <mif:argumentDatatype name="ENXP"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:property name="use" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:type name="DSET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="EntityNameUse"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="validTime" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="IVL">
            <mif:argumentDatatype name="TS"/>
         </mif:type>
      </mif:property>
      <mif:property name="canonical" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="EN"/>
      </mif:property>
      <mif:property name="equal" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(EN x, y)
      where x.nonNull.and(y.nonNull) {
   x.isEmpty.and(y.isEmpty).implies(x.equal(y));
   
   x.notEmpty.and(y.notEmpty).and(x.canonical.head.nonNull).implies(
      x.equal(y).equal(x.canonical.head.equal(y.canonical.head).and(x.canonical.tail.equal(y.canonical.tail))));
	  
   x.notEmpty.and(y.notEmpty).and(x.canonical.head.isNull).implies(
      x.equal(y).equal(y.canonical.head.isNull.and(x.canonical.tail.equal(y.canonical.tail))));
};					
</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="formatted" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(EN x)
      where x.nonNull {
   ((ST)x).equal(x.formatted);
};					
</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.NT"/>
      </mif:property>
      <mif:property name="demotion" sortKey="06" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(EN x)
      where x.nonNull {
 x.formatted.equal((ST) x);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.NT"/>
      </mif:property>
      <mif:property name="promotion" sortKey="07" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(ST x)
      where x.nonNull {
  ((EN)x).length.equal(1);
  ((EN)x).item(0).type.isNull;
  
  x.equal((ST)((EN)x));  
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ST"/>
         </mif:parameter>
         <mif:type name="TN"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="QTY" title="Quantity" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:property name="isComparableTo" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (QTY x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.isComparableTo(y).equal(x.lessOrEqual(y).or(y.lessOrEqual(x)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="lessOrEqual" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (QTY x, y, z)
   where x.nonNull.and(y.nonNull).and(z.nonNull) {
      x.lessOrEqual(x);                                  /* reflexive */
       x.equal(y).not.implies(x.lessOrEqual(y).implies(y.lessOrEqual(x)).not);    /* asymmetric */
      x.lessOrEqual(y).and(y.lessOrEqual(z))
       .implies(x.lessOrEqual(z))                        /* transitive */
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="lessThan" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (QTY x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.lessThan(y).equal(x.lessOrEqual(y)
                .and(x.equal(y).not));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="greaterThan" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (QTY x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.greaterThan(y).equal(y.lessThan(x));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="greaterOrEqual" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (QTY x, y, z)
      where x.nonNull.and(y.nonNull) {
   x.greaterOrEqual(y).equal(y.lessOrEqual(x));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="diffType" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    ownerScope="classifier"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QTY x) {
   x.diffType.implies(QTY);
   x.diffType.equal(QTY).not;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="minus" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QTZ x, y)
     where y.dataType.implies(x.dataType) {
   x.minus(y).datatype.implies(x.diffType);
};

invariant(QTZ x, y)
     where y.dataType.implies(x.diffType) {
   x.minus(y).datatype.implies(x.dataType);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QTY x, y)
      where y.datatype.equal(x.dataType).and(x.isComparableTo(y).Not) {
   x.minus(y).notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="QTY"/>
      </mif:property>
      <mif:property name="plus" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QTY x, y)
      where y.nonNull.and(x.nonNull).and(y.dataType.implies(x.dataType).and(x.isComparableTo(y))) {
   x.plus(y.minus(x)).equal(y);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QTY x, y)
      where y.dataType.implies(x.diffType).not {
   x.plus(y).notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type qualifier="baseDiff"/>
         </mif:parameter>
         <mif:type name="QTY"/>
      </mif:property>
      <mif:property name="originalText" sortKey="09" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="ED.TEXT"/>
      </mif:property>
      <mif:property name="promotion" sortKey="10" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="RTO">
            <mif:argumentDatatype name="QTY"/>
            <mif:argumentDatatype name="INT"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="QTZ" title="ZeroedQuantity" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTY"/>
      </mif:derivedFrom>
      <mif:property name="diffType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    ownerScope="classifier"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QTZ x) {
   x.diffType.equal(x.dataType)
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="minus" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QTZ x, y) {
   x.minus(y).datatype.implies(x.dataType);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTZ"/>
         </mif:parameter>
         <mif:type name="QTZ"/>
      </mif:property>
      <mif:property name="plus" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTZ"/>
         </mif:parameter>
         <mif:type name="QTZ"/>
      </mif:property>
      <mif:property name="isZero" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QTZ x) 
    where x.nonNull {
   x.minus(x).isZero;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="INT" title="IntegerNumber" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTZ"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x, o, i)
      where x.nonNull.and(o.isZero) {
   x.lessThan(x.successor);
   x.plus(o).equal(x);
   x.plus(y.successor).equal(x.plus(y).successor);
   x.times(o).equal(o);
   x.times(y.successor).equal(x.times(y)).plus(x);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="successor" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x, y)
      where x.successor(y) {
   x.lessThan(y).and.not(exists(INT z) {
      x.lessThan(z);
      z.lessThan(y);
      });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="predecessor" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x, y)
      where x.successor(y) {
   x.successor.predecessor.equal(x);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="diffType" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    ownerScope="classifier"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x) {
   x.diffType.implies(INT);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="plus" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x, y, o)
      where x.nonNull.and(y.nonNull).and(o.isZero) {
   x.plus(o).equal(x);
   x.plus(y.successor).equal(x.plus(y).successor);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="times" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x, y, i, o)
      where x.nonNull.and(x.isComparableTo(y)).and(o.isZero).and(i.isOne) {
   x.times(o).equal(o);
   x.times(i).equal(x);
   x.times(y.successor).equal(x.times(y)).plus(x);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="negated" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x)
      where x.nonNull {
   x.plus(x.negated).isZero;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="isNegative" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x)
      where x.nonNull {
   x.isNegative.equal(x.nonNegative.not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="nonNegative" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x, o)
      where x.nonNull.and(o.isZero) {
   x.nonNegative.equal(o.lessOrEqual(x));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="dividedBy" sortKey="09" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT dividend, REAL divisor)
      where dividend.nonNull.and(divisor.nonNull).and(divisor.isZero.not) {
   dividend.isZero.implies(dividend.dividedBy(divisor).isZero);
   dividend.isZero.not.implies(dividend.dividedBy(divisor).equals(dividend.times(divisor.inverted)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="dividedBy" sortKey="10" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT dividend, divisor, o, i)
      where dividend.nonNull.and(divisor.nonNull).and(divisor.isZero.not).and(o.isZero) {
   dividend.isZero.implies(dividend.dividedBy(divisor).equal(o));
   dividend.isZero.not.implies(dividend.dividedBy(divisor).equal(
      absolute(dividend).minus(absolute(divisor)).dividedBy(absolute(divisor))
                        .successor.times(sign(dividend)
                        .times(sign(divisor)))));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="remainder" sortKey="11" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x, y)
      where x.nonNull.and(y.nonNull) {
   x.reminder(y).equal(x.minus(x.dividedBy(z).times(y)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="isOne" sortKey="12" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x, y)
      where x.nonNull.and(y.nonNull) {
   x.isOne.and(y.isOne).implies(x.equal(y));
   x.isOne.and(y.isZero).implies(x.equal(y).not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="literal" sortKey="13" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
INT.literal ST.SIMPLE {
   INT digit : "0"         { $.isZero; }
             | "1"         { $.equal(0.successor); }
             | "2"         { $.equal(1.successor); }
             | "3"         { $.equal(2.successor); }
             | "4"         { $.equal(3.successor); }
             | "5"         { $.equal(4.successor); }
             | "6"         { $.equal(5.successor); }
             | "7"         { $.equal(6.successor); }
             | "8"         { $.equal(7.successor); }
             | "9"         { $.equal(8.successor); };

  INT uint   : digit       { $.equal($1); }
             | uint digit  { $.equal($1.times(9.successor).plus($2)); };

  INT        : uint        { $.equal($1); }
             | "+" uint    { $.equal($2); }
             | "-" uint    { $.equal($2.negated); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="equal" sortKey="14" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="REAL" title="RealNumber" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTZ"/>
      </mif:derivedFrom>
      <mif:property name="isComparableTo" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(REAL x, y)
      where x.nonNull.and(y.nonNull) {
   x.isComparableTo(y);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="diffType" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    ownerScope="classifier"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(REAL x) {
   x.diffType.implies(REAL);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="precision" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="plus" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(REAL x, y, z, o)
      where x.nonNull.and(y.nonNull).and(z.nonNull).and(o.isZero) {
   x.plus(o).equal(x);                             /* neutral element */
   x.plus(y).plus(z).equal(x.plus(y.plus(z)));     /* associative */
   x.plus(y).equal(y.plus(x));                     /* commutative */
   z.lessOrEqual(x).and(z.lessOrEqual(y)
                   .implies(z.lessOrEqual(x.plus(y))));
   x.lessOrEqual(y).implies(x.plus(z)
                   .lessOrEqual(y.plus(z)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type qualifier="baseDiff"/>
         </mif:parameter>
         <mif:type name="QTY"/>
      </mif:property>
      <mif:property name="negated" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(REAL x)
      where x.nonNull {
   x.plus(x.negated).isZero;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="isOne" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(REAL x, y)
      where x.nonNull.and(y.nonNull) {
   x.isOne.and(y.isOne).implies(x.equal(y));
   x.isOne.and(y.isZero).implies(x.equal(y).not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="times" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(REAL x, y, z, i, o)
      where x.nonNull.and(y.nonNull).and(z.nonNull)
             .and(i.isOne).and(o.isZero) {
   x.times(o).equal(o);
   x.times(i).equal(x);                                      /* neutral element */
   x.times(y).times(z).equal(x.times(y.times(z)));           /* associative */
   x.times(y).equal(y.times(x));                             /* commutative */
   x.times(y.plus(z)).equal(x.times(y).plus(x.times(z)));     /* distributive */
   o.lessOrEqual(x).and(o.lessOrEqual(y).implies(o.lessOrEqual(x.times(y))));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="dividedBy" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(REAL dividend, REAL divisor)
      where dividend.nonNull.and(divisor.nonNull).and(divisor.isZero.not) {
   dividend.isZero.implies(dividend.dividedBy(divisor).isZero);
   dividend.isZero.not.implies(dividend.dividedBy(divisor).equals(dividend.times(divisor.inverted)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="inverted" sortKey="09" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(REAL x, i)
      where x.isZero.not.and(i.isOne) {
   x.times(x.inverted).equal(i);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="power" sortKey="10" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(REAL x, y, z, o, i)
      where x.nonNull.and(y.nonNull).and(z.nonNull)
             .and(o.isZero).and(i.isOne) {
   forall(INT n)
         where n.nonNull {
      n.greaterThan(o).implies(
         x.power(n).equal(x.times(x.power(n.predecessor))));
      n.lessThan(o).implies(
         x.power(n).equal(x.power(n.negated).inverted));
      };
      x.power(o).equal(i);
      x.power(i).equal(x);
      x.power(y).power(z).equal(x.power(y.times(z)));
      x.power(y).times(x.power(z)).equal(x.power(y.plus(z)));
      x.power(y).inverted.equal(x.power(y.negated));
      x.power(y).power(y.inverted).equal(x);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="literal" sortKey="11" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
REAL.literal ST.SIMPLE {
   REAL            : mantissa                   { $.equal($1); }
                   | mantissa /[eE]/ INT        { $.equal($1.times(10.power($3)); };

   REAL mantissa   : /0*/ 0                     { $.isZero;
                                                  $.precision.equal(1); }
                   | /0*/ "." /0*/              { $.isZero;
                                                  $.precision.equal($3.length.successor); }
                   | /0*/ "." /0*/ fractional   { $.equal($4);
                                                  $.precision.equal($4.precision); }
                   | integer                    { $.equal($1); }
                   | integer "." fractional     { $.equal($1.plus($2));
                                                  $.precision.equal(
                                                  $1.precision.plus($3.precision)); };

   REAL integer    : uintval                    { $.equal($2); }
                   | "+" uintval                { $.equal($1.times($2)); }
                   | "-" uintval                { $.equal($1.times($2).negated); };

   REAL uintval    : /0*/ uint                  { $.equal($2); };

   REAL uint       : digit                      { $.equal($1);
                                                  $.precision.equal(1); }
                   | uint digit                 { $.equal($1.times(10).plus($2));
                                                  $.precision.equal(
                                                     $1.precision.successor); };

   REAL fractional : digit                      { $.equal($1.times(10.inverted));
                                                  $.precision.equal(1); }
                   | digit fractional           { $.equal(
                                                  $1.plus($2.times(10.inverted));
                                                  $.precision.equal(
                                                     $1.precision.successor); };

   INT digit       : /[0-9]/                    { $.equal($1); }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="promotion" sortKey="12" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT n, m)
      where n.nonNull.and(m.nonNull) {
   ((REAL)n.plus(m)).equal(((REAL)n).plus((REAL)m));
   ((REAL)n.times(m)).equal(((REAL)n).times((REAL)m));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="demotion" sortKey="13" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="equal" sortKey="14" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="RTO" title="Ratio" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTY"/>
      </mif:derivedFrom>
      <mif:parameter name="N" sortKey="1">
         <mif:type name="QTZ"/>
      </mif:parameter>
      <mif:parameter name="D" sortKey="2">
         <mif:type name="QTZ"/>
      </mif:parameter>
      <mif:property name="numerator" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="N" qualifier="parameter"/>
      </mif:property>
      <mif:property name="denominator" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(RTO x)
      where x.nonNull {
   x.denominator.isZero.not;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="D" qualifier="parameter"/>
      </mif:property>
      <mif:property name="literal" sortKey="03" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
RTO.literal ST.SIMPLE {
   RTO : QTY          { $.numerator.equal($1);
                        $.denominator.equal((INT)1); };
       | QTZ ":" QTZ  { $.numerator.equal($1);
                        $.denominator.equal($3); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="demotion" sortKey="04" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="demotion" sortKey="05" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="equal" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(RTO x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.numerator.equal(y.numerator).and(x.denominator.equal(y.denominator)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="RTO"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PQ" title="PhysicalQuantity" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTZ"/>
      </mif:derivedFrom>
      <mif:property name="value" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="unit" sortKey="02" propertyKind="variableProperty" visibility="public"
                    defaultValue="1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="UnitsOfMeasureCaseSensitive"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="codingRationale" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="SET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CodingRationale"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="translation" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:type name="DSET">
            <mif:argumentDatatype name="PQR"/>
         </mif:type>
      </mif:property>
      <mif:property name="canonical" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x)
      where x.nonNull {
   x.canonical.equal(x);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="equal" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.canonical.value
             .equal(y.canonical.value).and(
                x.canonical.unit.equal(y.canonical.unit)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="isComparableTo" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x, y)
      where x.nonNull.and(y.nonNull) {
   x.isComparableTo(y).equal(x.canonical.unit.equal(y.canonical.unit));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="diffType" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    ownerScope="classifier"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x) {
   x.diffType.implies(PQ);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x, y)
      where x.nonNull.and(x.isComparableTo(y)) {
   x.minus(y).canonical.unit.implies(x.canonical.unit);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="plus" sortKey="09" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PQ x, y)
      where x.nonNull.and(x.isComparableTo(y)) {
   x.canonical.plus(y.canonical).value.equal(
      x.canonical.value.plus(y.canonical.value));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="isOne" sortKey="10" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x, y)
      where x.nonNull.and(y.nonNull) {
   x.isOne.and(y.isOne).implies(x.equal(y));
   x.isOne.and(y.isZero).implies(x.equal(y).not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="times" sortKey="11" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x; REAL r)
      where x.nonNull.and(r.nonNull) {
   x.times(r).value.equal(x.value.times(r));
   x.times(r).isComparableTo(x);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="dividedBy" sortKey="12" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ dividend, REAL divisor)
      where dividend.nonNull.and(divisor.nonNull).and(divisor.isZero.not) {
   dividend.dividedBy(divisor).value.equal(dividend.value.dividedBy(divisor));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="times" sortKey="13" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x, y, z, i, o)
      where x.nonNull.and(y.nonNull).and(z.nonNull)
             .and(o.isZero).and(i.isOne) {
   x.times(o).equal(o);
   x.times(i).equal(x);             /* neutral element */
   x.times(y).times(z).equal(
            x.times(y.times(z)));   /* associative */
   x.times(y).equal(y.times(x));    /* commutative */
   o.lessOrEqual(x).and(o.lessOrEqual(y).implies(o.lessOrEqual(x.times(y))));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="PQ"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="dividedBy" sortKey="14" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ dividend, PQ divisor)
      where dividend.nonNull.and(divisor.nonNull).and(divisor.isZero.not) {
   dividend.isZero.implies(dividend.dividedBy(divisor).isZero);
   dividend.isZero.not.implies(dividend.dividedBy(divisor).equals(dividend.times(divisor.inverted)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="PQ"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="negated" sortKey="15" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x)
      where x.nonNull {
   x.plus(x.negated).isZero;
   x.negated.unit.equals(x.unit);
   x.negated.value.equals(x.value.negated);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="inverted" sortKey="16" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ this, that, one)
      where this.nonNull.and(that.nonNull).and(one.isOne) {
   this.times(this.inverted).equal(one);
   this.isComparableTo(that).implies(this.times(that.inverted).equal(one));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="power" sortKey="17" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PQ x, i; INT n, o) 
      where x.nonNull.and(i.isOne).and(n.nonNull.and(o.isZero)) {
   x.power(o).equal(i);
   n.greaterThan(o).implies(
      x.power(n).equal(x.times(x.power(n.predecessor))));
   n.lessThan(o).implies(
      x.power(n).equal(x.power(n.negated).inverted));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="literal" sortKey="18" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
PQ.literal ST.SIMPLE {
   PQ       : REAL unit    { $.value.equal($1);
                             $.unit.equal($2); }
   CS  unit : ST           { $.value.equal($1);
                             $.codeSystem.equal(2.16.840.1.113883.6.8); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="promotion" sortKey="19" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQ x, unity) 
      where x.nonNull.and.unity.isOne.and(x.isComparableTo(unity)) {
   unity.times((REAL)x).equal(x);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="demotion" sortKey="20" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="REAL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PQR" title="PhysicalQuantityRepresentation" datatypeKind="Definition"
                 visibility="protected">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="CV"/>
      </mif:derivedFrom>
      <mif:property name="value" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQR x)
    where x.nonNull {
  x.value.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="code" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="codeSystem" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="UID"/>
      </mif:property>
      <mif:property name="codeSystemName" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST.NT"/>
      </mif:property>
      <mif:property name="codeSystemVersion" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="displayName" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="originalText" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQR x) {
   x.originalText.notApplicable;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="ED.TEXT"/>
      </mif:property>
      <mif:property name="equal" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PQR x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.value.equal(y.value).and(((CD)x).equal((CD)y)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="PQR"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="MO" title="MonetaryAmount" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTZ"/>
      </mif:derivedFrom>
      <mif:property name="value" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(MO x) where x.nonNull {
  x.value.nonNull;
}</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
      <mif:property name="currency" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(MO x) where x.nonNull {
  x.currency.nonNull;
}</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="Currency"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="equal" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(MO x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.value.equal(y.value)
             .and(x.unit.equal(y.unit)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="isComparableTo" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(MO x, y)
      where x.nonNull.and(y.nonNull) {
   x.isComparableTo(y).equal(x.currency.equal(y.currency));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="diffType" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    ownerScope="classifier"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x) {
   x.diffType.implies(MO);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="plus" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (MO x, y)
      where x.nonNull.and(y.nonNull).and(x.currency.equal(y.currency)) {
   x.plus(y).currency.equal(x.currency);
   x.plus(y).value.equal(x.value.plus(y.value));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="MO"/>
         </mif:parameter>
         <mif:type name="MO"/>
      </mif:property>
      <mif:property name="times" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(MO x; REAL r)
      where x.nonNull.and(r.nonNull) {
   x.times(r).value.equal(x.value.times(r));
   x.times(r).currency.equal(x.currency);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="MO"/>
      </mif:property>
      <mif:property name="dividedBy" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(MO dividend, REAL divisor)
      where dividend.nonNull.and(divisor.nonNull).and(divisor.isZero.not) {
   dividend.isZero.implies(dividend.dividedBy(divisor).isZero);
   dividend.isZero.not.implies(dividend.dividedBy(divisor).equals(dividend.times(divisor.inverted)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="MO"/>
      </mif:property>
      <mif:property name="literal" sortKey="09" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
MO.literal ST.SIMPLE {
   MO           : currency value  { $.currency.equal($1); }
                                    $.value.equal($2);
   CS  currency : ST              { $.currency.value.equal($1);
                                    $.currency.codeSystem
                                    .equal(2.16.840.1.113883.6.9); }
   REAL value   : REAL           { $.value.equal($1); }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CAL" title="Calendar" datatypeKind="Definition" visibility="private">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="DSET">
            <mif:argumentDatatype name="CLCY"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:property name="name" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CAL c)
      where c.nonNull {
   c.name.nonNull;
   c.contains(c.head);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="CS"/>
      </mif:property>
      <mif:property name="head" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CLCY"/>
      </mif:property>
      <mif:property name="epoch" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="TS"/>
      </mif:property>
      <mif:property name="equal" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="CAL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="CLCY" title="CalendarCycle" datatypeKind="Definition"
                 visibility="private">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="ANY"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CLCY c)
      where c.nonNull {
   c.name.nonNull;
   c.start.equal(0).or(c.start.equal(1));
   c.digits.greaterThan(0);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="name" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CV"/>
      </mif:property>
      <mif:property name="ndigits" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="start" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="next" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CLCY"/>
      </mif:property>
      <mif:property name="max" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:parameter name="t" sortKey="1">
            <mif:type name="TS"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="sum" sortKey="06" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:parameter name="t" sortKey="1">
            <mif:type name="TS"/>
         </mif:parameter>
         <mif:parameter name="r" sortKey="2">
            <mif:type name="REAL"/>
         </mif:parameter>
         <mif:type name="TS"/>
      </mif:property>
      <mif:property name="value" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:parameter name="t" sortKey="1">
            <mif:type name="TS"/>
         </mif:parameter>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="equal" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(CLCY x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.ndigits.equal(y.ndigits).and(x.start.equal(y.start)).and(x.next.equal(y.next)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="CLCY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TS" title="PointInTime" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QTY"/>
      </mif:derivedFrom>
      <mif:property name="offset" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(TS x, PQ y)
      where x.nonNull.and(y.unit.code.equal("s")) {
   x.offset.isComparableTo(y);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="equal" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(TS x, y)
      where x.nonNull.and(y.nonNull) {
   x.equal(y).equal(x.offset.equal(y.offset)).and(x.precision.equal(y.precision));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="ANY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="lessOrEqual" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(TS x, y)
      where x.nonNull.and(y.nonNull) {
   x.lessOrEqual(y).nonNull.implies(x.offset.equal(y.offset));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (QTY x, y, z)
   where x.nonNull.and(y.nonNull).and(z.nonNull) {
      x.lessOrEqual(x);                                  /* reflexive */
      x.lessOrEqual(y).implies(y.lessOrEqual(x)).not;    /* asymmetric */
      x.lessOrEqual(y).and(y.lessOrEqual(z))
       .implies(x.lessOrEqual(z))                        /* transitive */
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QTY"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="calendar" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="GREG"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="Calendar"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="precision" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="timezone" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(TS x, y)
      where x.nonNull.and(y.nonNull) {
   x.timezone.isComparableTo("1 s");
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="diffType" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    ownerScope="classifier"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(TS x) {
   x.diffType.implies(PQ);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:type name="TYPE"/>
      </mif:property>
      <mif:property name="plus" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(TS x, PQ t)
      where x.nonNull.and(t.isComparableTo("1 s")) {
   x.plus(t).offset.equal(x.offset.plus(t));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="PQ"/>
         </mif:parameter>
         <mif:type name="TS"/>
      </mif:property>
      <mif:property name="minus" sortKey="09" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(TS x, y)
      where x.nonNull.and(y.nonNull) {
   x.minus(y).dataType.equal(PQ);
   x.minus(y).offset.equal(x.offset.plus(y.offset.negated));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="TS"/>
         </mif:parameter>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="minus" sortKey="10" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(TS x, PQ y)
      where x.nonNull.and(y.nonNull) {
   x.minus(y).dataType.equal(TS);
   x.minus(y).equal(x.plus(y.negated));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QTY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="PQ"/>
         </mif:parameter>
         <mif:type name="TS"/>
      </mif:property>
      <mif:property name="literal" sortKey="11" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
TS.literal ST.SIMPLE {
   TS   : cal timestamp($1)                  { $.equal($2); }
        | timestamp(GREG)                    { $.equal($1); };

   TS timestamp(Calendar C)
        : cycles(C.head, C.epoch) zone(C)    { $.equal($1.minus($2)); }
                                               $.timezone.equal($2); }
        | cycles(C.head, C.epoch)            { $.equal($1);
                                               $.timezone.unknown; };
   Calendar cal
        : /[a-zA-Z_][a-zA-Z0-9_]*:/          { $.equal($1); };

   TS cycles(CalendarCycle c, TS t)
        : cycle(c, t) cycles(c.next, $1)     { $.equal($2); }
        | cycle(c, t) "." REAL.fractional    { $.equal(c.sum($1, $3));
                                               $.precision.equal(
                                                  t.precision.plus($3.precision)); }
        | cycle(c, t)                        { $.equal($1); };

   TS cycle(CalendarCycle c, TS t)
        : /[0-9]{c.ndigits}/                 { $.equal(c.sum(t, $1));
                                                $.precision.equal(
                                                   t.precision.plus(c.ndigits)); };

   PQ zone(Calendar C)
        : "+" cycles(C.zonehead, C.epoch)    { $.equal($2.minus(C.epoch)); }
        | "-" cycles(C.zonehead, C.epoch)    { $.equal(C.epoch.minus($2)); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="EXPR" title="Expression" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="T" qualifier="parameter"/>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="expression" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="evaluate" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="EXPR">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="GLIST" title="GeneratedSequence" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="LIST"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(GLIST&lt;T&gt; list, INT index)
      where list.nonNull.and(index.nonNull) {
   list.period.nonNull.implies(list.item(index).equal(
      list.head.plus(item.dividedBy(list.increment.denominator)
          .remainder(list.period)).times(increment)));
   list.period.isNull.implies(list.item(index).equal(
      list.head.plus(item.dividedBy(list.increment.denominator))
          .times(increment)));
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="head" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="LIST"/>
         </mif:derivedFrom>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="increment" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(GLIST&lt;T&gt; x, T.diffType y) where x.nonNull.and(y.isZero) {
   x.increment.greaterThan(y);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="T" qualifier="parameterDiff"/>
      </mif:property>
      <mif:property name="period" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(GLIST&lt;T&gt; x) where x.nonNull {
   x.period.nonNull.implies(x.period.greaterThan(0));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="denominator" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(GLIST&lt;T&gt; x) where x.nonNull {
   x.denominator.nonNull;
   x.denominator.greaterThan(0);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="INT"/>
      </mif:property>
      <mif:property name="equal" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="LIST">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="SLIST" title="SampledSequence" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="LIST"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SLIST&lt;T&gt; list, INT index)
      where list.nonNull.and(index.nonNegative) {
   list.item(index).equal(
      list.scale.times(digits.item(index))
          .plus(list.origin));
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="origin" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="scale" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="T" qualifier="parameterDiff"/>
      </mif:property>
      <mif:property name="digits" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:type name="LIST">
            <mif:argumentDatatype name="INT"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="LIST">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="QSET" title="ContinuousSet" isAbstract="true" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="SET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
            <mif:argumentDatatype name="CEQ">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:argumentDatatype>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="hull" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QSET&lt;T&gt; s) where s.nonNull {
   forall(QTY x, y) where s.contains(x).and(s.contains(y)) {
      x.isComparableTo(y);
  };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QSET&lt;T&gt; s) where s.nonNull {
   s.hull.contains(s);
   forall(T e)
         where s.contains(e) {
      s.hull.low.lessOrEqual(e);
      e.lessOrEqual(s.hull.high);
      };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="intervalAt" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QSET&lt;T&gt; s, TS t) {
   s.contains(t).not.implies(s.intervalAfter(t).equal(s.intervalAtOrAfter(t)));
   s.contains(t).implies(s.intervalAfter(t).equal(
               s.except(intervalAtOrAfter(t)).intervalAtOrAfter(t)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="intervalAtOrAfter" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QSET&lt;T&gt; s, T t, IVL&lt;T&gt; v) {
   v.equal(s.intervalAtOrAfter(t)).equal(
      s.contains(o).and(
         forall(IVL&lt;T&gt; u) where x.contains(u) {
            u.contains(v).implies(u.equal(v));
            })
         .and(v.contains(t).or(forall(T i) where t.lessOrEqual(i)
               .and(i.lessThan(v.low)) {
            s.contains(i).not; })));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="intervalAfter" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QSET&lt;T&gt; s, TS t) {
   s.contains(t).not.implies(s.intervalAfter(t).equal(s.intervalAtOrAfter(t)));
   s.contains(t).implies(s.intervalAfter(t).equal(
               s.except(intervalAtOrAfter(t)).intervalAtOrAfter(t)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="interleaves" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QSET&lt;T&gt; A, B)
      where x.nonNull.and(y.nonNull) {
   A.interleaves(B).equal(
      forall(IVL&lt;T&gt; a, b, c; T t)
         where a.equal(A.intervalAtOrAfter(t))
                .and(b.equal(B.intervalAtOrAfter(a.low)))
                .and(c.equal(A.intervalAtOrAfter(b.high))) {
            b.equal(B.intervalAtOrAfter(a.high));
            a.low.lessOrEqual(b.low);
            c.equal(A.intervalAtOrAfter(b.high));
            c.equal(a).or(c.equal(A.intervalAfter(a.high)));
            });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QSET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="periodicHull" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QSET&lt;T&gt; A, B, C)
      where A.interleaves(B) {
   A.periodicHull(B).equal(C).equal(
      forall(IVL&lt;T&gt; a, b; T t)
         where a.equal(A.intervalAtOrAfter(t))
                .and(b.equal(B.intervalAtOrAfter(a.low))) {
            C.contains(c).equal(c.equal(a.hull(b)));
            });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="QSET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="QSET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="SET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="originalText" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="ED.TEXT"/>
      </mif:property>
      <mif:property name="demotion" sortKey="09" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(QSET&lt;T&gt;  x)
      where x.isEmpty {
   ((LIST&lt;IVL&lt;T&gt;&gt;)x).isEmpty; };

invariant(QSET&lt;T&gt; x, IVL&lt;T&gt; first)
      where x.notEmpty.and(x.hull.low.nonNull)
                      .and(first.equal(x.intervalAtOrAfter(x.hull.low))) {
   ((LIST&lt;IVL&lt;T&gt;&gt;)x).head.equal(first);
   ((LIST&lt;IVL&lt;T&gt;&gt;)x).tail.equal(
      (LIST&lt;IVL&lt;T&gt;&gt;)x.except(first));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="LIST">
            <mif:argumentDatatype name="IVL">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:argumentDatatype>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="QSU" title="ContinuousSetUnion" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="terms" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:type name="DSET">
            <mif:argumentDatatype name="QSET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:argumentDatatype>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="QSI" title="ContinuousSetIntersection" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="terms" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:type name="DSET">
            <mif:argumentDatatype name="QSET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:argumentDatatype>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="QSD" title="ContinuousSetDifference" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="minuend" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="QSET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="subtrahend" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="QSET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="QSP" title="ContinuousSetPeriodicHull" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="low" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="QSET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="high" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="QSET">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="QSC" title="CodedContinuousSet" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
   </mif:datatype>
   <mif:datatype name="IVL" title="Interval" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="low" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; x; T e)
      where x.nonNull.and(x.contains(e)) {
   x.low.lessOrEqual(e);
   x.low.nullFlavor.implies(NullFlavor.PINF).not;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="high" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; x; T e)
      where x.nonNull.and(x.contains(e)) {
   e.lessOrEqual(x.high);
   x.high.nullFlavor.implies(NullFlavor.NINF).not;
};

invariant(IVL&lt;T&gt; x)
    where x.low.nonNull.and(x.high.nonNull) {
	x.low.lessOrEqual(x.high);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="width" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; x) where x.low.nonNull.and(x.high.nonNull) {
   x.low.lessOrEqual(x.high);
   x.width.equal(x.high.minus(x.low));
};

invariant(IVL&lt;T&gt; x, T.diffType z) 
  where x.low.nonNull.and(x.high.nonNull).and(z.isZero) {
   x.width.greaterOrEqual(z);
};

invariant(IVL&lt;T&gt; x) {
   x.width.dataType.implies(T.diffType);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="QTY"/>
      </mif:property>
      <mif:property name="center" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; x)
      where x.low.nonNull.and(x.high.nonNull) {
   x.center.equal(x.low.plus(x.width.dividedBy(2)));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; x) 
   where x.low.nonNull.xor(x.high.nonNull) {
   x.low.nullFlavor.implies("NINF").implies(x.center.nullFlavor.implies("NINF"));
   x.high.nullFlavor.implies("PINF").implies(x.center.nullFlavor.implies("PINF"));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="lowClosed" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; x)
      where x.nonNull {
   x.low.nonNull.implies(x.lowClosed.equal(x.contains(x.low)));
   x.low.isNull.implies(x.lowClosed.not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="highClosed" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; x)
      where x.nonNull {
   x.high.nonNull.implies(x.highClosed.equal(x.contains(x.high)));
   x.high.isNull.implies(x.highClosed.not);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="any" sortKey="07" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; x)
      where x.nonNull.and(x.any.nonNull) {
   x.low.isNull;
   x.high.isNull;
   x.center.isNull;
   x.width.isNull;
   x.lowClosed.isNull;
   x.highClosed.isNull;
};

invariant(IVL&lt;T&gt; ivl, T t)
       where ivl.any.nonNull.and(vl.any.equals(t)) {
  ivl.contains(t);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(SET&lt;T&gt; set, IVL&lt;T&gt; ivl)
    where set.nonNull.and(ivl.nonNull) {  
  set.contains(ivl.any).implies(set.intersection(ivl).isEmpty.not);
  set.contains(ivl.any).not.implies(set.intersection(ivl).isNull);
};
</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="hull" sortKey="08" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; i) 
    where i.nonNull {
   i.equal(i.hull());
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QSET"/>
         </mif:derivedFrom>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="hull" sortKey="09" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; h, IVL&lt;T&gt; i, j)
      where h.nonNull.and(h.equal(i.hull(j))) {
   i.low.lessOrEqual(j.low).implies(h.low.equal(i.low));
   j.low.lessOrEqual(i.low).implies(h.low.equal(j.low));
   i.high.lessOrEqual(j.high).implies(h.high.equal(j.high));
   j.high.lessOrEqual(i.high).implies(h.high.equal(i.high));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="IVL">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="literal" sortKey="10" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
IVL&lt;T&gt;.literal ST.SIMPLE {
   IVL&lt;T&gt; range : interval                { $.equal($1); }
                | dash                    { $.equal($1); }
                | comparator              { $.equal($1); }
                | center_width            { $.equal($1); }
                | width                   { $.equal($1); }
                | center                  { $.equal($1); }
                | any                     { $.equal($1); };

   IVL&lt;T&gt; interval
                : open T ";" T close;     { $.low.equal($2);
                                            $.high.equal($4);
                                            $.lowClosed.equal($1);
                                            $.highClosed.equal($5); };
   BL open      : "["                     { $.equal(true); }
                | "]"                     { $.equal(false); };
   BL close     : "]"                     { $.equal(true); }
                | "["                     { $.equal(false); };
   IVL&lt;T&gt; width
                : open T.diffType close   { $.width.equal($2);
                                            $.lowClosed.equal($1);
                                            $.highClosed.equal($3); };
   IVL&lt;T&gt; center_width
                : T width                 { $.center.equal($1);
                                            $.width.equal($2.width);
                                            $.lowClosed.equal($2.lowClosed);
                                            $.highClosed.equal($2.highClosed); };

   IVL&lt;T&gt; center
                : T width                 { $.center.equal($1)};
                
   IVL&lt;T&gt; any
                : "? T "?"                 { $.any.equal($1)};
                
   IVL&lt;T&gt; dash  : T "-" T;                { $.low.equal($2);
                                            $.high.equal($4);
                                            $.lowClosed.equal(true);
                                            $.highClosed.equal(true); };
   IVL&lt;TS&gt; comparator
                : "&lt;"  T                  { $.high.equal(T);
                                            $.high.closed(false);
                                            $.low.negativelyInfinite; }
                | "&gt;"  T                  { $.low.equal(T);
                                            $.low.closed(false);
                                            $.high.positivelyInfinite; }
                | "&lt;=" T                  { $.high.equal(T);
                                            $.high.closed(true);
                                            $.low.negativelyInfinite; }
                | "&gt;=" T                  { $.low.equal(T);
                                            $.low.closed(true);
                                            $.high.positivelyInfinite; };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="promotion" sortKey="11" propertyKind="promotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(INT x) where x.nonNull {
   ((IVL&lt;INT&gt;)x).low.equal(x);
   ((IVL&lt;INT&gt;)x).high.equal(x);
   ((IVL&lt;INT&gt;)x).highClosed;
   ((IVL&lt;INT&gt;)x).lowClosed;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(T x) where x.nonNull.and(T.equals(INT).not).and(T.equals(TS).not) {
   ((IVL&lt;T&gt;)x).center.equal(x);
   ((IVL&lt;T&gt;)x).highClosed.not;
   ((IVL&lt;T&gt;)x).lowClosed;
   /* cannot make formal statements about low and high*/
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(TS x) where x.nonNull {
   /*
   ((IVL&lt;TS&gt;)x).low.equal(x); 
   
   this is not true, the precision of low is arbitrarily high
   and therefore they are not equal */
   
   ((IVL&lt;T&gt;)x).highClosed.not;
   ((IVL&lt;T&gt;)x).lowClosed;
   
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="demotion" sortKey="12" propertyKind="demotion" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(IVL&lt;T&gt; x)
      where x.nonNull {
   x.center.nonNull.implies(((T)x).equal(x.center));
   x.low.nonNull.and(x.high.nonNull).implies(((T)x).equal(x.center).or(((IVL&lt;T&gt;)((T)x)).equal(x)));
   x.high.nonNull.and(x.low.isNull).implies(((T)x).equal(x.high));
   x.low.nonNull.and(x.high.isNull).implies(((T)x).equal(x.low));
   x.low.isNull.and(x.high.isNull).and(x.any.isNull).implies(((T)x).notApplicable);
   x.any.nonNull.implies(((T)x).equal(x.any));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="equal" sortKey="13" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="SET">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:type>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="IVL_PQ" title="Interval&lt;PhysicalQuantity&gt;" datatypeKind="Binding"
                 visibility="public">
      <mif:binding>
         <mif:targetDatatype name="IVL"/>
         <mif:argumentDatatype name="PQ"/>
      </mif:binding>
      <mif:property name="value" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="IVL">
            <mif:argumentDatatype name="REAL"/>
         </mif:type>
      </mif:property>
      <mif:property name="unit" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CS"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="IVL_TS" title="Interval&lt;PointInTime&gt;" datatypeKind="Binding"
                 visibility="public">
      <mif:binding>
         <mif:targetDatatype name="IVL"/>
         <mif:argumentDatatype name="TS"/>
      </mif:binding>
      <mif:property name="literal" sortKey="01" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
   IVL&lt;TS&gt; hull : TS ".." TS     { $.equal(((IVL&lt;TS&gt;)$1)
                                    .hull((IVL&lt;TS&gt;)$3));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PIVL" title="PeriodicInterval" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="TS"/>
      </mif:parameter>
      <mif:property name="phase" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PIVL&lt;T&gt; x)
      where x.nonNull {
   x.phase.nonNull.implies(x.phase.width.lessThan(x.period));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="period" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PIVL&lt;T&gt; x)
      where x.nonNull {
   x.period.nonNull;
};

invariant(PIVL x) {
   period.isZero.not;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="frequency" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PIVL&lt;T&gt; x)
      where x.nonNull {
   x.frequency.nonNull;
   x.period.equal(x.frequency.denominator.dividedBy(x.frequency.numerator));
};
</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="RTO">
            <mif:argumentDatatype name="INT"/>
            <mif:argumentDatatype name="PQ.TIME"/>
         </mif:type>
      </mif:property>
      <mif:property name="count" sortKey="04" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="INT.POS"/>
      </mif:property>
      <mif:property name="displayFrequencyInd" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="alignment" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CalendarCycle"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="isFlexible" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="literal" sortKey="08" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
PIVL&lt;T&gt;.literal ST.SIMPLE {
   PIVL&lt;T&gt;    : S2                  { $.equal($1); }
              | S2 "IST"            { $.phase.equal($1.phase);
                                      $.period.equal($1.period);
                                      $.isFlexible.equal(true); };
   PIVL&lt;T&gt; S2 : S1                  { $.equal($1); }
              | S1 "@" "(" ST ")"   { $.phase.equal($1.phase);
                                      $.period.equal($1.period);
                                      $.alignment.equal($4); };
   PIVL&lt;T&gt; S1 :
      IVL&lt;T&gt; "/" "(" QTY ")"        { $.phase.equal($1);
                                      $.period.equal($3); }
              | "/" "(" QTY ")"     { $.period.equal($2); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="equal" sortKey="09" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="SET"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="EIVL" title="EventRelatedPeriodicInterval" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="QSET"/>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="TS"/>
      </mif:parameter>
      <mif:property name="event" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(EIVL&lt;T&gt; x)
     where x.nonNull {
   x.event.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="TimingEvent"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="offset" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="IVL">
            <mif:argumentDatatype name="PQ"/>
         </mif:type>
      </mif:property>
      <mif:property name="literal" sortKey="03" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
EIVL&lt;TS&gt;.literal ST.SIMPLE {
   EIVL&lt;TS&gt; : event          { $.event.equal($1); }
            | event offset   { $.event.equal($1);
                               $.offset.equal($2); };
   CS event : ST             { $.code.equal($1);
                               $.codeSystem.equal(2.16.840.1.113883.5.1019); }
   IVL&lt;PQ&gt; offset
            : "+" IVL&lt;PQ&gt;    { $.equal($2); }
            | "-" IVL&lt;PQ&gt;    { $.low.equal($2.high.negate);
                               $.high.equal($2.low.negate);
                               $.width.equal($2.width);
                               $.lowClosed($2.highClosed);
                               $.highClosed($2.lowClosed); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
      <mif:property name="intervalAt" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(EIVL&lt;T&gt; x, T eventTime, IVL&lt;T&gt; v)
      where v.equal(x.intervalAt(eventTime)) {
   v.low.equal(eventTime.plus(x.offset.low));
   v.high.equal(eventTime.plus(x.offset.high));
   v.lowClosed.equal(x.offset.lowClosed);
   v.highClosed.equal(x.offset.highClosed);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(EIVL&lt;T&gt; x, T y) {
   x.contains(y).equal(exists(T e, IVL&lt;T&gt; v)
      where EVENT(x.event, y).and(v.resolvedAt(y)) {
         v.contains(y);
         });
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="QSET"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="TS"/>
         </mif:parameter>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="SET"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="QSET_TS" title="ContinuousSet&lt;PointInTime&gt;" datatypeKind="Binding"
                 visibility="public">
      <mif:binding>
         <mif:targetDatatype name="QSET"/>
         <mif:argumentDatatype name="TS"/>
      </mif:binding>
      <mif:property name="literal" sortKey="01" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
GTS.literal ST.SIMPLE {
   GTS symbol : union                      { $.equal($1); }
              | exclusion                  { $.equal($1); };
   SET&lt;TS&gt; union
              : symbol ";" intersection    { $.equal($1.union($3)); }
              | intersection               { $.equal($1); };
   SET&lt;TS&gt; exclusion
              : symbol "\" intersection    { $.equal($1.except($3)); }
              | intersection               { $.equal($1); };
   SET&lt;TS&gt; intersection
              : hull intersection          { $.equal($1.intersection($2)); }
              | hull                       { $.equal($1); };
   SET&lt;TS&gt; hull
              : hull ".." factor           { $.equal($1.periodicHull($3)); }
              | factor                     { $.equal($1); };
   SET&lt;TS&gt; factor
              : IVL&lt;TS&gt;                    { $.equal($1); }
              | QSC&lt;TS&gt;                    { $.code.equal($1); }
              | PIVL&lt;TS&gt;                   { $.equal($1); }
              | EIVL&lt;TS&gt;                   { $.equal($1); }
              | "(" GTS ")"                { $.equal($1); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="GTS" title="GeneralTimingSpecification" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="annotated">
         <mif:targetDatatype name="QSET">
            <mif:argumentDatatype name="TS"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
   </mif:datatype>
   <mif:datatype name="UVP" title="UncertainValueProbabilistic" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="T" qualifier="parameter"/>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="probability" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(UVP&lt;T&gt; x)
      where x.nonNull.and(x.probability.nonNull) {
   ((IVL&lt;REAL&gt;)"[0;1]").contains(x.probability);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="REAL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="NPPD" title="NonParametricProbabilityDistribution"
                 datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="DSET">
            <mif:argumentDatatype name="UVP">
               <mif:argumentDatatype name="T" qualifier="parameter"/>
            </mif:argumentDatatype>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="ANY"/>
      </mif:parameter>
      <mif:property name="mostLikely" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(NPPD&lt;T&gt; x)
      where x.nonNull {
   x.notEmpty;
   x.contains(x.mostLikely(n));
   forall(UVP&lt;T&gt; d, e; DSET&lt;UVP&lt;T&gt;&gt; m; INT n)
         where x.contains(d).and(m.equal(x.mostLikely(n)))
                .and(m.contains(e)) {
      e.greaterOrEqual(d).or(m.contains(d));
      };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="n" sortKey="1">
            <mif:type name="INT"/>
         </mif:parameter>
         <mif:type name="UVP">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="equal" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="BL"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="URG" title="UncertainRange" datatypeKind="Definition" visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="T" qualifier="parameter"/>
      </mif:derivedFrom>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="range" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(URG&lt;T&gt; x) 
      where x.range.nonNull {
   x.range.any.isNull;
   x.range.center.nonNull;
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="IVL">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
      <mif:property name="couldBe" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(URG&lt;T&gt; x, T t) 
    where x.range.nonNull {
  x.couldBe(t).equals(x.range.contains(t));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:parameter name="value" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="equal" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(URG&lt;T&gt; x, y) 
    where x.nonNull.and(y.nonNull) {
  x.equal(y).equal(x.range.equal(y));
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:parameter name="x" sortKey="1">
            <mif:type name="T" qualifier="parameter"/>
         </mif:parameter>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="BN" title="BooleanNonNull" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="BL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (BN x) {
   x.isNull.not;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="isNull" sortKey="01" propertyKind="variableProperty" visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BN"/>
      </mif:property>
      <mif:property name="nonNull" sortKey="02" propertyKind="variableProperty" visibility="public"
                    fixedValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BN"/>
      </mif:property>
      <mif:property name="other" sortKey="03" propertyKind="variableProperty" visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="notApplicable" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="unknown" sortKey="05" propertyKind="variableProperty" visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="nullFlavor" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="NullFlavor"/>
         </mif:vocabularySpecification>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ED.TEXT" title="TextWithReference" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ED.TEXT x) where x.nonNull {
  x.mediaType.equal("text/plain");
  x.integrityCheck.isNull;
  x.thumbnail.isNull;
  x.compression.isNull;
  x.translation.isEmpty;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="mediaType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="text/plain"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="MediaType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="compression" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CompressionAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="integrityCheck" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="BIN"/>
      </mif:property>
      <mif:property name="integrityCheckAlgorithm" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="SHA-1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="IntegrityCheckAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="thumbnail" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="translation" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="ED"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ED.SIGNATURE" title="DigitalSignature" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ED.SIGNATURE x) where x.nonNull {
  x.reference.isNull;
  x.integrityCheck.isNull;
  x.thumbnail.isNull;
  x.description.isNull;
  x.compression.isNull;
  x.language.isNull;
  x.mediaType.equal("text/xml");
  x.translation.isEmpty;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="mediaType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="text/xml"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="MediaType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="language" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="HumanLanguage"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="compression" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CompressionAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="reference" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="TEL.URL"/>
      </mif:property>
      <mif:property name="integrityCheck" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="BIN"/>
      </mif:property>
      <mif:property name="integrityCheckAlgorithm" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="SHA-1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="IntegrityCheckAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="description" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="thumbnail" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="translation" sortKey="09" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="ED"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ED.IMAGE" title="Image" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ED.IMAGE x) where x.nonNull {
  x.mediaType.code.subList(0,6).equal("image/");
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="data" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="BIN"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ED.STRUCTURED_TEXT" title="StructuredText" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ED.STRUCTURED_TEXT x) where x.nonNull {
  x.mediaType.equal("text/x-hl7-text+xml");
  x.translation.isEmpty;
  x.description.notApplicable;
  x.thumbnail.notApplicable;
  x.compression.notApplicable;
  x.reference.notApplicable;
  x.integrityCheck.notApplicable;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="mediaType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="text/x-hl7-text+xml"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="MediaType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="description" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="thumbnail" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="translation" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="ED"/>
         </mif:type>
      </mif:property>
      <mif:property name="compression" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CompressionAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="reference" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="TEL.URL"/>
      </mif:property>
      <mif:property name="integrityCheck" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="BIN"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ED.STRUCTURED_TITLE" title="StructuredTitle" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ED"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ED.STRUCTURED_TITLE x) where x.nonNull {
  x.mediaType.equal("text/x-hl7-title+xml");
  x.translation.isEmpty;
  x.description.notApplicable;
  x.thumbnail.notApplicable;
  x.compression.notApplicable;
  x.reference.notApplicable;
  x.integrityCheck.notApplicable;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="mediaType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="text/x-hl7-title+xml"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="MediaType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="description" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="ST"/>
      </mif:property>
      <mif:property name="thumbnail" sortKey="03" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="ED"/>
      </mif:property>
      <mif:property name="translation" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="ED"/>
         </mif:type>
      </mif:property>
      <mif:property name="compression" sortKey="05" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="CompressionAlgorithm"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="reference" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="TEL.URL"/>
      </mif:property>
      <mif:property name="integrityCheck" sortKey="07" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="BIN"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ST.NT" title="StringNoTranslations" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ST"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ST.NT x) where x.nonNull {
  x.translation.isEmpty;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="translation" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="ED"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ST.SIMPLE" title="StringSimple" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ST.NT"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ST.SIMPLE x) where x.nonNull {
  x.language.notApplicable;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="language" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ED"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="HumanLanguage"/>
         </mif:vocabularySpecification>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="SC.NT" title="CodedStringNoTranslations" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="SC"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (SC.NT x) where x.nonNull {
  x.translation.isEmpty;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="CV" title="CodedValue" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="CD"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (CV x) where x.nonNull {
  x.translation.isEmpty;
  x.source.isNull;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="translation" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="CD"/>
         </mif:type>
      </mif:property>
      <mif:property name="source" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="CD"/>
         </mif:derivedFrom>
         <mif:type name="CD"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TEL.URL" title="LocatableResource" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TEL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TEL.URL x) where x.nonNull {
 x.use.isEmpty.and(
  x.scheme.equal("file").or(
   x.scheme.equal("ftp").or(
    x.scheme.equal("http").or(
     x.scheme.equal("https").or(
      x.scheme.equal("cid").or(
       x.scheme.equal("nfs")))))));
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="use" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="TEL"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="TelecommunicationAddressUse"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="scheme" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="URL"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="URLScheme"/>
         </mif:vocabularySpecification>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TEL.PHONE" title="TelephoneAddress" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TEL.PERSON"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TEL.PHONE x) where x.nonNull {
  x.scheme.equal("tel");
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="scheme" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="URL"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="URLScheme"/>
         </mif:vocabularySpecification>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TEL.EMAIL" title="EmailAddress" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TEL.PERSON"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TEL.EMAIL x) where x.nonNull {
  x.scheme.equal("mailto");
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="scheme" sortKey="01" propertyKind="variableProperty" visibility="public"
                    fixedValue="mailto"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="URL"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="URLScheme"/>
         </mif:vocabularySpecification>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PNXP" title="PersonNamePart" datatypeKind="Flavor" visibility="protected">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ENXP"/>
      </mif:derivedFrom>
      <mif:property name="qualifier" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ENXP"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="EntityNamePartQualifier"/>
         </mif:vocabularySpecification>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PN" title="PersonName" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="EN"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PN x) where x.nonNull {
   forall(ENXP part)
         where x.contains(part) {
      part.qualifier.contains(EntityPartNameQualifier.LS).not;
      }
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="ONXP" title="OrganizationNamePart" datatypeKind="Flavor"
                 visibility="protected">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ENXP"/>
      </mif:derivedFrom>
      <mif:property name="partType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ENXP"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="EntityNamePartType"/>
         </mif:vocabularySpecification>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="ON" title="OrganizationName" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="EN"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (ON x) where x.nonNull {
  forall(ENXP part)
         where x.contains(part) {
      part.type.implies(EntityNamePartType.FAM).not;
      part.type.implies(EntityNamePartType.GIV).not;
      }
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="TNXP" title="TrivialNamePart" datatypeKind="Flavor"
                 visibility="protected">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="ENXP"/>
      </mif:derivedFrom>
      <mif:property name="partType" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ENXP"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="EntityNamePartType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="qualifier" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ENXP"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="CS"/>
         </mif:type>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="EntityNamePartQualifier"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="isNull" sortKey="03" propertyKind="variableProperty" visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BN"/>
      </mif:property>
      <mif:property name="nonNull" sortKey="04" propertyKind="variableProperty" visibility="public"
                    fixedValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BN"/>
      </mif:property>
      <mif:property name="other" sortKey="05" propertyKind="variableProperty" visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="notApplicable" sortKey="06" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="unknown" sortKey="07" propertyKind="variableProperty" visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="nullFlavor" sortKey="08" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="NullFlavor.NA"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="ANY"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="NullFlavor"/>
         </mif:vocabularySpecification>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TN" title="TrivialName" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="EN"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TN x) where x.nonNull {
   x.head.nonNull;
   x.head.partType.isNull;
   x.tail.isEmpty;
   x.formatted.equal(x.head);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="length" sortKey="01" propertyKind="variableProperty" visibility="public"
                    fixedValue="1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="LIST"/>
         </mif:derivedFrom>
         <mif:type name="INT"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="INT.NONNEG" title="IntegerNonNegative" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="INT"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (INT.NONNEG x) where x.nonNull {
  x.greaterOrEqual(0);
  x.nullFlavor.implies(NullFlavor.NINF).not;
  x.isNegative.not;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="isNegative" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="INT"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="INT.POS" title="IntegerPositive" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="INT.NONNEG"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (INT.POS x) where x.nonNull {
  x.greaterThan(0);
  x.isZero.not;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="isZero" sortKey="01" propertyKind="variableProperty" visibility="public"
                    fixedValue="false"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="QTZ"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PQ.TIME" title="LengthOfTime" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="PQ"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PQ.TIME x, PQ y) where x.nonNull.and(y.unit.equal("s")) {
  x.isComparableTo(y);
  x.translation.isEmpty;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="unit" sortKey="01" propertyKind="variableProperty" visibility="public"
                    defaultValue="1"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="PQ"/>
         </mif:derivedFrom>
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="UnitsOfMeasureCaseSensitive"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="translation" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="*"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="PQ"/>
         </mif:derivedFrom>
         <mif:type name="DSET">
            <mif:argumentDatatype name="PQR"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TS.DATE" title="Date" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TS"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.DATE x) where x.nonNull {
  x.timezone.isNull;
  x.precision.lessOrEqual(8);
  x.calendar.implies(Calendar.GREG);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="timezone" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="TS"/>
         </mif:derivedFrom>
         <mif:type name="PQ"/>
      </mif:property>
      <mif:property name="precision" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:enumerationValue>4</mif:enumerationValue>
         <mif:enumerationValue>6</mif:enumerationValue>
         <mif:enumerationValue>8</mif:enumerationValue>
         <mif:derivedFrom>
            <mif:targetDatatype name="TS"/>
         </mif:derivedFrom>
         <mif:type name="INT"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TS.DATE.FULL" title="FullDate" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TS.DATE"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.DATE.FULL x) where x.nonNull {
  x.precision.equal(8);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="precision" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="8"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="TS.DATE"/>
         </mif:derivedFrom>
         <mif:type name="INT"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TS.DATETIME" title="DateTime" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TS"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.DATETIME x) where x.nonNull {
  x.precision.lessOrEqual(14);
  x.calendar.implies(Calendar.GREG);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="precision" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:enumerationValue>4</mif:enumerationValue>
         <mif:enumerationValue>6</mif:enumerationValue>
         <mif:enumerationValue>8</mif:enumerationValue>
         <mif:enumerationValue>10</mif:enumerationValue>
         <mif:enumerationValue>12</mif:enumerationValue>
         <mif:enumerationValue>14</mif:enumerationValue>
         <mif:derivedFrom>
            <mif:targetDatatype name="TS"/>
         </mif:derivedFrom>
         <mif:type name="INT"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TS.DATETIME.FULL" title="FullDateTime" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TS.DATETIME"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.DATETIME.FULL x) where x.nonNull {
  x.precision.equal(14);
  x.timezone.nonNull;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="precision" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="14"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="TS.DATETIME"/>
         </mif:derivedFrom>
         <mif:type name="INT"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="TS.INSTANT" title="InstantInTime" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="TS.DATETIME"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (TS.DATETIME.FULL x) where x.nonNull {
  x.precision.equal(17);
  x.timezone.nonNull;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="precision" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="17"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="TS.DATETIME"/>
         </mif:derivedFrom>
         <mif:type name="INT"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="IVL.LOW" title="IntervalLow" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="IVL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL.LOW x) where x.nonNull {
  x.low.nonNull;
  x.lowClosed;
  x.high.isNull;
  x.highClosed.isNull;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="low" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="lowClosed" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="high" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="highClosed" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="IVL.HIGH" title="IntervalHigh" datatypeKind="Flavor" visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="IVL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL.HIGH x) where x.nonNull {
  x.high.nonNull;
  x.highClosed;
  x.low.isNull;
  x.lowClosed.isNull;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="low" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="lowClosed" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="high" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="highClosed" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    fixedValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="IVL.WIDTH" title="IntervalWidth" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="IVL"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (IVL.WIDTH x) where x.nonNull {
  x.width.nonNull;
  x.low.isNull;
  x.lowClosed.isNull;
  x.high.isNull;  /* strictly this is superfluous */
  x.highClosed.isNull;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="low" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="lowClosed" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="high" sortKey="03" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="T" qualifier="parameter"/>
      </mif:property>
      <mif:property name="highClosed" sortKey="04" propertyKind="variableProperty"
                    visibility="public"
                    defaultValue="true"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="NP">
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="BL"/>
      </mif:property>
      <mif:property name="width" sortKey="05" propertyKind="variableProperty" visibility="public"
                    isMandatory="true"
                    minimumMultiplicity="1"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="IVL"/>
         </mif:derivedFrom>
         <mif:type name="QTY"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="URG.LOW" title="UncertainRangeLow" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="URG"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (URG.LOW x) {
  exists(IVL.LOW r) {
    x.range.equal(r);
  }
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="range" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="URG"/>
         </mif:derivedFrom>
         <mif:type name="IVL.LOW">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="URG.HIGH" title="UncertainRangeHigh" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="URG"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (URG.HIGH x) where x.unknown {
  exists(IVL.HIGH r) {
    x.range.equal(r);
  }
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:property name="range" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:derivedFrom>
            <mif:targetDatatype name="URG"/>
         </mif:derivedFrom>
         <mif:type name="IVL.HIGH">
            <mif:argumentDatatype name="T" qualifier="parameter"/>
         </mif:type>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="GTS.BOUNDEDPIVL" title="BoundedPeriodicInterval" datatypeKind="Flavor"
                 visibility="public">
      <mif:derivedFrom relationship="restriction">
         <mif:targetDatatype name="QSI">
            <mif:argumentDatatype name="TS"/>
         </mif:targetDatatype>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (GTS.BOUNDEDPIVL x) where x.nonNull {
  x.dataType.equals(QSI&lt;TS&gt;);
  ((QSI&lt;TS&gt;)x).terms.cardinality.equal(2);
  exists(IVL&lt;TS&gt; y) {((QSI&lt;TS&gt;)x).terms.contains(y)};
  exists(PIVL&lt;TS&gt; z) {((QSI&lt;TS&gt;)x).terms.contains(z)};  
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
   </mif:datatype>
   <mif:datatype name="PPD" title="ParametricProbabilityDistribution" datatypeKind="Definition"
                 visibility="public">
      <mif:derivedFrom relationship="extension">
         <mif:targetDatatype name="T" qualifier="parameter"/>
      </mif:derivedFrom>
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant (PPD&lt;T&gt; x)  {
  x.datatype.implies(INT).not;
  x.datatype.implies(RTO).not;
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:parameter name="T" sortKey="1">
         <mif:type name="QTY"/>
      </mif:parameter>
      <mif:property name="standardDeviation" sortKey="01" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PPD x) {
   x.standardDeviation.dataType.implies(T.diffType);
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="T" qualifier="parameterDiff"/>
      </mif:property>
      <mif:property name="distributionType" sortKey="02" propertyKind="variableProperty"
                    visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CS"/>
         <mif:vocabularySpecification>
            <mif:conceptDomain name="ProbabilityDistributionType"/>
         </mif:vocabularySpecification>
      </mif:property>
      <mif:property name="literal" sortKey="03" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
PPD&lt;T&gt;.literal ST.SIMPLE {
   PPD&lt;T&gt;  : T "(" type QTY ")"  { ((T)$).equal($1);
                                   $.distributionType.equal($3);
                                   $.standardDeviation.equal($4); };
   CV type : ST                  { $.value.equal($1);
                                   $.codeSystem.equal(2.16.840.1.113883.5.1020); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PPD_REAL" title="ParametricProbabilityDistribution&lt;RealNumber&gt;"
                 datatypeKind="Binding"
                 visibility="public">
      <mif:binding>
         <mif:targetDatatype name="PPD"/>
         <mif:argumentDatatype name="REAL"/>
      </mif:binding>
      <mif:property name="literal" sortKey="01" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
PPD&lt;REAL&gt;.literal ST.SIMPLE {
   PPD&lt;REAL&gt; mantissa
           : REAL.mantissa "(" type QTY ")"  { ((T)$).equal($1);
                                                   $.distributionType.equal($3);
                                                   $.standardDeviation.equal($4); }
           | REAL.mantissa                   { $.equal($1);
                                               $.distributionType.equal($3);
                                               $.standardDeviation.equal(
                                                  $1.leastSignificantDigit.times(0.5)); };
   CS type : ST                              { $.value.equal($1);
                                               $.system.equal(2.16.840.1.113883.5.1019); };
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="PPD"/>
         </mif:derivedFrom>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PPD_PQ" title="ParametricProbabilityDistribution&lt;PhysicalQuantity&gt;"
                 datatypeKind="Binding"
                 visibility="public">
      <mif:annotations>
         <mif:appInfo>
            <mif:formalConstraint>
               <mif:text/>
               <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
invariant(PPD&lt;PQ&gt; x)
      where x.nonNull {
   x.value.nonNull;
   ((REAL)x.value).equal(((PQ)x).value);
   x.unit.equal(((PQ)x).unit);
   x.value.standardDeviation.equal(x.standardDeviation.value);
   x.standardDeviation.unit.equal(x.unit);
};</mif:alternateFormalExpression>
            </mif:formalConstraint>
         </mif:appInfo>
      </mif:annotations>
      <mif:binding>
         <mif:targetDatatype name="PPD"/>
         <mif:argumentDatatype name="PQ"/>
      </mif:binding>
      <mif:property name="value" sortKey="01" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="PPD">
            <mif:argumentDatatype name="REAL"/>
         </mif:type>
      </mif:property>
      <mif:property name="unit" sortKey="02" propertyKind="variableProperty" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:type name="CS"/>
      </mif:property>
      <mif:property name="literal" sortKey="03" propertyKind="literal" visibility="public"
                    isMandatory="false"
                    minimumMultiplicity="0"
                    maximumMultiplicity="1"
                    conformance="R">
         <mif:annotations>
            <mif:appInfo>
               <mif:formalConstraint>
                  <mif:text/>
                  <mif:alternateFormalExpression encoding="HL7DatatypeDefinitionLanguage">
PPD&lt;PQ&gt;.literal ST.SIMPLE {
   PPD&lt;PQ&gt; : PPD&lt;REAL&gt; " " unit  { $.value.equal($1);
                                   $.unit.equal($3); }
};</mif:alternateFormalExpression>
               </mif:formalConstraint>
            </mif:appInfo>
         </mif:annotations>
         <mif:derivedFrom>
            <mif:targetDatatype name="PPD"/>
         </mif:derivedFrom>
         <mif:type name="ST.SIMPLE"/>
      </mif:property>
   </mif:datatype>
   <mif:datatype name="PPD_TS" title="ParametricProbabilityDistribution&lt;PointInTime&gt;"
                 datatypeKind="Binding"
                 visibility="public">
      <mif:binding>
         <mif:targetDatatype name="PPD"/>
         <mif:argumentDatatype name="TS"/>
      </mif:binding>
   </mif:datatype>
</mif:datatypeModelLibrary>