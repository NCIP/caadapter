<?xml version="1.0" encoding="UTF-8"?>
<xsd:schema elementFormDefault="qualified" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:sch="http://www.ascc.net/xml/schematron">
  <xsd:simpleType name="NullFlavor">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="NI" />
      <xsd:enumeration value="INV" />
      <xsd:enumeration value="OTH" />
      <xsd:enumeration value="NINF" />
      <xsd:enumeration value="PINF" />
      <xsd:enumeration value="UNC" />
      <xsd:enumeration value="DER" />
      <xsd:enumeration value="UNK" />
      <xsd:enumeration value="ASKU" />
      <xsd:enumeration value="NAV" />
      <xsd:enumeration value="QS" />
      <xsd:enumeration value="NASK" />
      <xsd:enumeration value="TRC" />
      <xsd:enumeration value="MSK" />
      <xsd:enumeration value="NA" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="UpdateMode">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="A" />
      <xsd:enumeration value="AU" />
      <xsd:enumeration value="U" />
      <xsd:enumeration value="R" />
      <xsd:enumeration value="I" />
      <xsd:enumeration value="D" />
      <xsd:enumeration value="K" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="Compression">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="DF" />
      <xsd:enumeration value="GZ" />
      <xsd:enumeration value="ZL" />
      <xsd:enumeration value="Z" />
      <xsd:enumeration value="BZ" />
      <xsd:enumeration value="Z7" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="IntegrityCheckAlgorithm">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="SHA1" />
      <xsd:enumeration value="SHA256" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="TelecommunicationAddressUse">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="H" />
      <xsd:enumeration value="HP" />
      <xsd:enumeration value="HV" />
      <xsd:enumeration value="WP" />
      <xsd:enumeration value="DIR" />
      <xsd:enumeration value="PUB" />
      <xsd:enumeration value="BAD" />
      <xsd:enumeration value="TMP" />
      <xsd:enumeration value="AS" />
      <xsd:enumeration value="EC" />
      <xsd:enumeration value="MC" />
      <xsd:enumeration value="PG" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_TelecommunicationAddressUse">
    <xsd:list itemType="TelecommunicationAddressUse" />
  </xsd:simpleType>
  <xsd:simpleType name="IdentifierScope">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="BUSN" />
      <xsd:enumeration value="OBJ" />
      <xsd:enumeration value="VER" />
      <xsd:enumeration value="VW" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="IdentifierReliability">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="ISS" />
      <xsd:enumeration value="VER" />
      <xsd:enumeration value="UNV" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="AddressPartType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="AL" />
      <xsd:enumeration value="ADL" />
      <xsd:enumeration value="UNID" />
      <xsd:enumeration value="UNIT" />
      <xsd:enumeration value="DAL" />
      <xsd:enumeration value="DINST" />
      <xsd:enumeration value="DINSTA" />
      <xsd:enumeration value="DINSTQ" />
      <xsd:enumeration value="DMOD" />
      <xsd:enumeration value="DMODID" />
      <xsd:enumeration value="SAL" />
      <xsd:enumeration value="BNR" />
      <xsd:enumeration value="BNN" />
      <xsd:enumeration value="BNS" />
      <xsd:enumeration value="STR" />
      <xsd:enumeration value="STB" />
      <xsd:enumeration value="STTYP" />
      <xsd:enumeration value="DIR" />
      <xsd:enumeration value="INT" />
      <xsd:enumeration value="CAR" />
      <xsd:enumeration value="CEN" />
      <xsd:enumeration value="CNT" />
      <xsd:enumeration value="CPA" />
      <xsd:enumeration value="CTY" />
      <xsd:enumeration value="DEL" />
      <xsd:enumeration value="POB" />
      <xsd:enumeration value="PRE" />
      <xsd:enumeration value="STA" />
      <xsd:enumeration value="ZIP" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="PostalAddressUse">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="H" />
      <xsd:enumeration value="HP" />
      <xsd:enumeration value="HV" />
      <xsd:enumeration value="WP" />
      <xsd:enumeration value="DIR" />
      <xsd:enumeration value="PUB" />
      <xsd:enumeration value="BAD" />
      <xsd:enumeration value="TMP" />
      <xsd:enumeration value="PHYS" />
      <xsd:enumeration value="PST" />
      <xsd:enumeration value="ABC" />
      <xsd:enumeration value="IDE" />
      <xsd:enumeration value="SYL" />
      <xsd:enumeration value="SRCH" />
      <xsd:enumeration value="SNDX" />
      <xsd:enumeration value="PHON" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_PostalAddressUse">
    <xsd:list itemType="PostalAddressUse" />
  </xsd:simpleType>
  <xsd:simpleType name="EntityNamePartType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="FAM" />
      <xsd:enumeration value="GIV" />
      <xsd:enumeration value="PFX" />
      <xsd:enumeration value="SFX" />
      <xsd:enumeration value="DEL" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="EntityNamePartQualifier">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="LS" />
      <xsd:enumeration value="AC" />
      <xsd:enumeration value="NB" />
      <xsd:enumeration value="PR" />
      <xsd:enumeration value="VV" />
      <xsd:enumeration value="AD" />
      <xsd:enumeration value="BR" />
      <xsd:enumeration value="SP" />
      <xsd:enumeration value="CL" />
      <xsd:enumeration value="IN" />
      <xsd:enumeration value="TITLE" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_EntityNamePartQualifier">
    <xsd:list itemType="EntityNamePartQualifier" />
  </xsd:simpleType>
  <xsd:simpleType name="EntityNameUse">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="C" />
      <xsd:enumeration value="I" />
      <xsd:enumeration value="L" />
      <xsd:enumeration value="P" />
      <xsd:enumeration value="A" />
      <xsd:enumeration value="R" />
      <xsd:enumeration value="OR" />
      <xsd:enumeration value="SRCH" />
      <xsd:enumeration value="PHON" />
      <xsd:enumeration value="SNDX" />
      <xsd:enumeration value="ABC" />
      <xsd:enumeration value="SYL" />
      <xsd:enumeration value="IDE" />
      <xsd:enumeration value="ASGN" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_EntityNameUse">
    <xsd:list itemType="EntityNameUse" />
  </xsd:simpleType>
  <xsd:simpleType name="CalendarCycle">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="CY" />
      <xsd:enumeration value="MY" />
      <xsd:enumeration value="CM" />
      <xsd:enumeration value="CW" />
      <xsd:enumeration value="WY" />
      <xsd:enumeration value="DM" />
      <xsd:enumeration value="CD" />
      <xsd:enumeration value="DY" />
      <xsd:enumeration value="DW" />
      <xsd:enumeration value="HD" />
      <xsd:enumeration value="CH" />
      <xsd:enumeration value="NH" />
      <xsd:enumeration value="CN" />
      <xsd:enumeration value="SN" />
      <xsd:enumeration value="CS" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="TimingEvent">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="HS" />
      <xsd:enumeration value="AC" />
      <xsd:enumeration value="ACM" />
      <xsd:enumeration value="ACD" />
      <xsd:enumeration value="ACV" />
      <xsd:enumeration value="IC" />
      <xsd:enumeration value="ICM" />
      <xsd:enumeration value="ICD" />
      <xsd:enumeration value="ICV" />
      <xsd:enumeration value="PC" />
      <xsd:enumeration value="PCM" />
      <xsd:enumeration value="PCD" />
      <xsd:enumeration value="PCV" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="CodingRationale">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="O" />
      <xsd:enumeration value="P" />
      <xsd:enumeration value="R" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="set_CodingRationale">
    <xsd:list itemType="CodingRationale" />
  </xsd:simpleType>
  <xsd:simpleType name="UncertaintyType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="U" />
      <xsd:enumeration value="N" />
      <xsd:enumeration value="LN" />
      <xsd:enumeration value="G" />
      <xsd:enumeration value="E" />
      <xsd:enumeration value="X2" />
      <xsd:enumeration value="T" />
      <xsd:enumeration value="F" />
      <xsd:enumeration value="B" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType mixed="true" name="StrucDoc.Text">
    <xsd:sequence>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element name="footnote" type="StrucDoc.Footnote" />
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml" />
        <xsd:element name="sub" type="StrucDoc.Sub" />
        <xsd:element name="sup" type="StrucDoc.Sup" />
        <xsd:element name="content" type="StrucDoc.Content" />
        <xsd:element name="br" type="StrucDoc.Br" />
        <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia" />
        <xsd:element name="paragraph" type="StrucDoc.Paragraph" />
        <xsd:element name="list" type="StrucDoc.List" />
        <xsd:element name="table" type="StrucDoc.Table" />
      </xsd:choice>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:attributeGroup name="StrucDoc.Base">
    <xsd:attribute name="ID" type="xsd:ID" use="optional" />
    <xsd:attribute name="language" type="Code" use="optional" />
    <xsd:attribute name="styleCode" type="set_Code" use="optional" />
  </xsd:attributeGroup>
  <xsd:simpleType name="XmlID">
    <xsd:restriction base="xsd:ID" />
  </xsd:simpleType>
  <xsd:simpleType name="Code">
    <xsd:restriction base="xsd:string" />
  </xsd:simpleType>
  <xsd:simpleType name="set_Code">
    <xsd:list itemType="Code" />
  </xsd:simpleType>
  <xsd:complexType mixed="true" name="StrucDoc.Footnote">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="Some content required">
          <sch:rule abstract="true" id="StrucDoc.Footnote-0">
            <sch:assert test="count(*|text()[normalize-space(.)!=&#39;&#39;])!=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element name="footnote" type="StrucDoc.Footnote" />
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml" />
        <xsd:element name="sub" type="StrucDoc.Sub" />
        <xsd:element name="sup" type="StrucDoc.Sup" />
        <xsd:element name="content" type="StrucDoc.Content" />
        <xsd:element name="br" type="StrucDoc.Br" />
        <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia" />
        <xsd:element name="paragraph" type="StrucDoc.Paragraph" />
        <xsd:element name="list" type="StrucDoc.List" />
        <xsd:element name="table" type="StrucDoc.Table" />
      </xsd:choice>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.FootnoteRef">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have a reference">
          <sch:rule abstract="true" id="StrucDoc.FootnoteRef-0">
            <sch:assert test="@IDREF" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute name="IDREF" type="xsd:IDREF" use="optional" />
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:simpleType name="XmlIDREF">
    <xsd:restriction base="xsd:IDREF" />
  </xsd:simpleType>
  <xsd:complexType mixed="true" name="StrucDoc.LinkHtml">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="StrucDoc.LinkHtml-0">
            <sch:assert test="count(*|text()[normalize-space(.)!=&#39;&#39;])!=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element name="footnote" type="StrucDoc.Footnote" />
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
      </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="name" type="xsd:string" use="optional" />
    <xsd:attribute name="href" type="xsd:string" use="optional" />
    <xsd:attribute name="rel" type="xsd:string" use="optional" />
    <xsd:attribute name="rev" type="xsd:string" use="optional" />
    <xsd:attribute name="title" type="xsd:string" use="optional" />
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Sub">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="text must not be empty">
          <sch:rule abstract="true" id="StrucDoc.Sub-0">
            <sch:assert test="string-length(text()) != 0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Sup">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="text must not be empty">
          <sch:rule abstract="true" id="StrucDoc.Sup-0">
            <sch:assert test="string-length(text()) != 0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Content">
    <xsd:sequence>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element name="footnote" type="StrucDoc.Footnote" />
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml" />
        <xsd:element name="sub" type="StrucDoc.Sub" />
        <xsd:element name="sup" type="StrucDoc.Sup" />
        <xsd:element name="content" type="StrucDoc.Content" />
        <xsd:element name="br" type="StrucDoc.Br" />
        <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia" />
      </xsd:choice>
    </xsd:sequence>
    <xsd:attribute name="revised" type="StrucDoc.Revised" use="optional" />
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:simpleType name="StrucDoc.Revised">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="insert" />
      <xsd:enumeration value="delete" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="StrucDoc.Br" />
  <xsd:complexType name="StrucDoc.RenderMultiMedia">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one reference">
          <sch:rule abstract="true" id="StrucDoc.RenderMultiMedia-0">
            <sch:assert test="@referencedObject" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:sequence>
      <xsd:element name="caption" type="StrucDoc.Caption" minOccurs="0" maxOccurs="1" />
    </xsd:sequence>
    <xsd:attribute name="referencedObject" type="set_IDREF" use="optional" />
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Caption">
    <xsd:sequence>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element name="footnote" type="StrucDoc.Footnote" />
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml" />
        <xsd:element name="sub" type="StrucDoc.Sub" />
        <xsd:element name="sup" type="StrucDoc.Sup" />
      </xsd:choice>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:simpleType name="set_IDREF">
    <xsd:list itemType="xsd:IDREF" />
  </xsd:simpleType>
  <xsd:complexType mixed="true" name="StrucDoc.Paragraph">
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.Captioned">
        <xsd:sequence>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="footnote" type="StrucDoc.Footnote" />
            <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
            <xsd:element name="linkHtml" type="StrucDoc.LinkHtml" />
            <xsd:element name="sub" type="StrucDoc.Sub" />
            <xsd:element name="sup" type="StrucDoc.Sup" />
            <xsd:element name="content" type="StrucDoc.Content" />
            <xsd:element name="br" type="StrucDoc.Br" />
            <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia" />
          </xsd:choice>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Captioned">
    <xsd:sequence>
      <xsd:element name="caption" type="StrucDoc.Caption" minOccurs="0" maxOccurs="1" />
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.List">
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.Captioned">
        <xsd:sequence>
          <xsd:element name="item" type="StrucDoc.Item" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="listType" type="StrucDoc.ListType" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="StrucDoc.ListType">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="ordered_" />
      <xsd:enumeration value="unordered_" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType mixed="true" name="StrucDoc.Item">
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.Captioned">
        <xsd:sequence>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="footnote" type="StrucDoc.Footnote" />
            <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
            <xsd:element name="linkHtml" type="StrucDoc.LinkHtml" />
            <xsd:element name="sub" type="StrucDoc.Sub" />
            <xsd:element name="sup" type="StrucDoc.Sup" />
            <xsd:element name="content" type="StrucDoc.Content" />
            <xsd:element name="br" type="StrucDoc.Br" />
            <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia" />
            <xsd:element name="paragraph" type="StrucDoc.Paragraph" />
            <xsd:element name="list" type="StrucDoc.List" />
            <xsd:element name="table" type="StrucDoc.Table" />
          </xsd:choice>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Table">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="columns">
          <sch:rule abstract="true" id="StrucDoc.Table-0">
            <sch:assert test="not(col) or not(column)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.Captioned">
        <xsd:sequence>
          <xsd:element name="col" type="StrucDoc.Col" minOccurs="0" maxOccurs="unbounded" />
          <xsd:element name="colgroup" type="StrucDoc.ColGroup" minOccurs="0" maxOccurs="unbounded" />
          <xsd:element name="thead" type="StrucDoc.TRowGroup" minOccurs="0" maxOccurs="1" />
          <xsd:element name="tfoot" type="StrucDoc.TRowGroup" minOccurs="0" maxOccurs="1" />
          <xsd:element name="tbody" type="StrucDoc.TRowGroup" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="summary" type="xsd:string" use="optional" />
        <xsd:attribute name="width" type="StrucDoc.Length" use="optional" />
        <xsd:attribute name="border" type="StrucDoc.Length" use="optional" />
        <xsd:attribute name="frame" type="StrucDoc.Frame" use="optional" />
        <xsd:attribute name="rules" type="StrucDoc.Rules" use="optional" />
        <xsd:attribute name="cellspacing" type="StrucDoc.Length" use="optional" />
        <xsd:attribute name="cellpadding" type="StrucDoc.Length" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.Col">
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.ColItem" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.ColItem">
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.TableItem">
        <xsd:attribute name="span" type="xsd:int" default="1" use="optional" />
        <xsd:attribute name="width" type="StrucDoc.Length" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.TableItem">
    <xsd:attribute name="align" type="StrucDoc.Align" use="optional" />
    <xsd:attribute name="char" type="xsd:string" use="optional" />
    <xsd:attribute name="charoff" type="StrucDoc.Length" use="optional" />
    <xsd:attribute name="valign" type="StrucDoc.VAlign" use="optional" />
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:simpleType name="StrucDoc.Align">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="left" />
      <xsd:enumeration value="center" />
      <xsd:enumeration value="right" />
      <xsd:enumeration value="justify" />
      <xsd:enumeration value="char" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.Length">
    <xsd:restriction base="xsd:string" />
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.VAlign">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="top" />
      <xsd:enumeration value="middle" />
      <xsd:enumeration value="bottom" />
      <xsd:enumeration value="baseline" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:complexType name="StrucDoc.ColGroup">
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.ColItem">
        <xsd:sequence>
          <xsd:element name="col" type="StrucDoc.Col" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.TRowGroup">
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.TableItem">
        <xsd:sequence>
          <xsd:element name="tr" type="StrucDoc.TRow" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="StrucDoc.TRow">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="cells">
          <sch:rule abstract="true" id="StrucDoc.TRow-0">
            <sch:assert test="th|td" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.TableItem">
        <xsd:sequence>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="th" type="StrucDoc.TCell" />
            <xsd:element name="td" type="StrucDoc.TCell" />
          </xsd:choice>
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.TCell">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no nested tables">
          <sch:rule abstract="true" id="StrucDoc.TCell-0">
            <sch:assert test="not(@table)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="StrucDoc.TableItem">
        <xsd:sequence>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="footnote" type="StrucDoc.Footnote" />
            <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
            <xsd:element name="linkHtml" type="StrucDoc.LinkHtml" />
            <xsd:element name="sub" type="StrucDoc.Sub" />
            <xsd:element name="sup" type="StrucDoc.Sup" />
            <xsd:element name="content" type="StrucDoc.Content" />
            <xsd:element name="br" type="StrucDoc.Br" />
            <xsd:element name="renderMultiMedia" type="StrucDoc.RenderMultiMedia" />
            <xsd:element name="paragraph" type="StrucDoc.Paragraph" />
            <xsd:element name="list" type="StrucDoc.List" />
            <xsd:element name="table" type="StrucDoc.Table" />
          </xsd:choice>
        </xsd:sequence>
        <xsd:attribute name="abbr" type="xsd:string" use="optional" />
        <xsd:attribute name="axis" type="xsd:string" use="optional" />
        <xsd:attribute name="headers" type="set_IDREF" use="optional" />
        <xsd:attribute name="scope" type="StrucDoc.CellScope" use="optional" />
        <xsd:attribute name="rowspan" type="xsd:int" default="1" use="optional" />
        <xsd:attribute name="colspan" type="xsd:int" default="1" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:simpleType name="StrucDoc.CellScope">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="row" />
      <xsd:enumeration value="col" />
      <xsd:enumeration value="rowgroup" />
      <xsd:enumeration value="colgroup" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.Frame">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="void" />
      <xsd:enumeration value="above" />
      <xsd:enumeration value="below" />
      <xsd:enumeration value="hsides" />
      <xsd:enumeration value="lhs" />
      <xsd:enumeration value="rhs" />
      <xsd:enumeration value="vsides" />
      <xsd:enumeration value="box" />
      <xsd:enumeration value="border" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="StrucDoc.Rules">
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="none" />
      <xsd:enumeration value="groups" />
      <xsd:enumeration value="rows" />
      <xsd:enumeration value="cols" />
      <xsd:enumeration value="all" />
    </xsd:restriction>
  </xsd:simpleType>
  <xsd:simpleType name="Uid">
    <xsd:restriction base="xsd:string" />
  </xsd:simpleType>
  <xsd:simpleType name="Uri">
    <xsd:restriction base="xsd:anyURI" />
  </xsd:simpleType>
  <xsd:complexType name="BL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value if not null">
          <sch:rule abstract="true" id="BL-0">
            <sch:assert test="@nullFlavor or (not(@nullFlavor) and @value)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:attribute name="value" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ANY">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no ANY unless null">
          <sch:rule abstract="true" id="ANY-0">
            <sch:assert test="todo" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="HXIT">
        <xsd:attribute name="nullFlavor" type="NullFlavor" use="optional" />
        <xsd:attribute name="flavorId" type="xsd:string" use="optional" />
        <xsd:attribute name="updateMode" type="UpdateMode" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="HXIT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="extension requires root">
          <sch:rule abstract="true" id="HXIT-0">
            <sch:assert test="not(@controlActExtension) or @controlActRoot" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute name="validTimeLow" type="xsd:string" use="optional" />
    <xsd:attribute name="validTimeHigh" type="xsd:string" use="optional" />
    <xsd:attribute name="controlActRoot" type="Uid" use="optional" />
    <xsd:attribute name="controlActExtension" type="xsd:string" use="optional" />
  </xsd:complexType>
  <xsd:complexType name="BL.NONNULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="BL.NONNULL cannot be null">
          <sch:rule abstract="true" id="BL.NONNULL-0">
            <sch:assert test="not(@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="BL">
        <xsd:attribute name="nullFlavor" type="NullFlavor" use="prohibited" />
        <xsd:attribute name="value" type="xsd:boolean" use="required" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="content is required if not null">
          <sch:rule abstract="true" id="ED-0">
            <sch:assert test="@nullFlavor or @value or xml or data" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="only one of value, data, xml">
          <sch:rule abstract="true" id="ED-1">
            <sch:assert test="count(*[self::value or self::xml or self::data])&#60;=1" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="integrityCheckAlgorithm required">
          <sch:rule abstract="true" id="ED-2">
            <sch:assert test="not(integrityCheck) or @integrityCheckAlgorithm" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="thumbnails do not use reference">
          <sch:rule abstract="true" id="ED-3">
            <sch:assert test="not(thumbnail) or thumbnail[not(@nullFlavor and reference)]" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="thumbnails do not have thumbnails">
          <sch:rule abstract="true" id="ED-4">
            <sch:assert test="not(thumbnail) or thumbnail[not(thumbnail)]" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="compression only on binary">
          <sch:rule abstract="true" id="ED-5">
            <sch:assert test="(@compression and data) or not(@compression or data)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="mediaType cannot be null">
          <sch:rule abstract="true" id="ED-6">
            <sch:assert test="@mediaType" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="value implies mediaType is text/plain">
          <sch:rule abstract="true" id="ED-7">
            <sch:assert test="not(@value) or (@value and (not(@mediaType) or @mediaType=&#39;text/plain&#39;))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no charset for value or xml">
          <sch:rule abstract="true" id="ED-8">
            <sch:assert test="not(@value or xml) or not(@charset)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="ED-9">
            <sch:assert test="count(*[self::reference or self::thumbnail][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no nested translations">
          <sch:rule abstract="true" id="ED-10">
            <sch:assert test="not(translation) or thumbnail[not(translation)]" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no value if null">
          <sch:rule abstract="true" id="ED-11">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@value))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no data if null">
          <sch:rule abstract="true" id="ED-12">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@data))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no xml if null">
          <sch:rule abstract="true" id="ED-13">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@xml))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no reference if null">
          <sch:rule abstract="true" id="ED-14">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@reference))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no mediaType if null">
          <sch:rule abstract="true" id="ED-15">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@mediaType))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no charset if null">
          <sch:rule abstract="true" id="ED-16">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@charset))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no language if null">
          <sch:rule abstract="true" id="ED-17">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@language))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no compression if null">
          <sch:rule abstract="true" id="ED-18">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@compression))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no integrityCheck if null">
          <sch:rule abstract="true" id="ED-19">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@integrityCheck))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no integrityCheckAlgorithm if null">
          <sch:rule abstract="true" id="ED-20">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@integrityCheckAlgorithm))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no thumbnail if null">
          <sch:rule abstract="true" id="ED-21">
            <sch:assert test="not(@nullFlavor) or (not(thumbnail) or thumbnail\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no translation if null">
          <sch:rule abstract="true" id="ED-22">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@translation))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="data" type="xsd:base64Binary" minOccurs="0" maxOccurs="1" />
          <xsd:element name="xml" type="xsd:anyType" minOccurs="0" maxOccurs="1" />
          <xsd:element name="reference" type="TEL.URL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="integrityCheck" type="xsd:base64Binary" minOccurs="0" maxOccurs="1" />
          <xsd:element name="thumbnail" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="description" type="ST" minOccurs="0" maxOccurs="1" />
          <xsd:element name="translation" type="ED" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="optional" />
        <xsd:attribute name="mediaType" type="xsd:string" default="text/plain" use="optional" />
        <xsd:attribute name="charset" type="Code" use="optional" />
        <xsd:attribute name="language" type="Code" use="optional" />
        <xsd:attribute name="compression" type="Compression" use="optional" />
        <xsd:attribute name="integrityCheckAlgorithm" type="IntegrityCheckAlgorithm" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TEL.URL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no use">
          <sch:rule abstract="true" id="TEL.URL-0">
            <sch:assert test="not(use)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="schemes">
          <sch:rule abstract="true" id="TEL.URL-1">
            <sch:assert test="(starts-with(@value, &#34;file&#34;) or starts-with(@value, &#34;ftp&#34;) or starts-with(@value, &#34;http&#34;) or starts-with(@value, &#34;https&#34;) or starts-with(@value, &#34;nfs&#34;))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="TEL">
        <xsd:sequence>
          <xsd:element name="useablePeriod" type="QSET_TS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="use" type="TelecommunicationAddressUse" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TEL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value is required">
          <sch:rule abstract="true" id="TEL-0">
            <sch:assert test="@nullFlavor or (not(@nullFlavor) and @value)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no value if null">
          <sch:rule abstract="true" id="TEL-1">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@value))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no use if null">
          <sch:rule abstract="true" id="TEL-2">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@use))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no useablePeriod if null">
          <sch:rule abstract="true" id="TEL-3">
            <sch:assert test="not(@nullFlavor) or (not(thumbnail) or useablePeriod\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on TEL attributes">
          <sch:rule abstract="true" id="TEL-4">
            <sch:assert test="count(*[self::useablePeriod][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="useablePeriod" type="QSET_TS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:anyURI" use="optional" />
        <xsd:attribute name="use" type="set_TelecommunicationAddressUse" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.TEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="text only">
          <sch:rule abstract="true" id="ED.TEXT-0">
            <sch:assert test="@mediaType = &#34;&#39;text/plain&#39;&#34;" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no xml">
          <sch:rule abstract="true" id="ED.TEXT-1">
            <sch:assert test="not(xml)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no data">
          <sch:rule abstract="true" id="ED.TEXT-2">
            <sch:assert test="not(data)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no integrityCheck">
          <sch:rule abstract="true" id="ED.TEXT-3">
            <sch:assert test="not(integrityCheck)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no thumbnail">
          <sch:rule abstract="true" id="ED.TEXT-4">
            <sch:assert test="not(thumbnail)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no compression">
          <sch:rule abstract="true" id="ED.TEXT-5">
            <sch:assert test="not(@compression)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="ED.TEXT-6">
            <sch:assert test="not(translation)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED">
        <xsd:sequence>
          <xsd:element name="data" type="xsd:base64Binary" minOccurs="0" maxOccurs="0" />
          <xsd:element name="xml" type="xsd:anyType" minOccurs="0" maxOccurs="0" />
          <xsd:element name="reference" type="TEL.URL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="integrityCheck" type="xsd:base64Binary" minOccurs="0" maxOccurs="0" />
          <xsd:element name="thumbnail" type="ED" minOccurs="0" maxOccurs="0" />
          <xsd:element name="description" type="ST" minOccurs="0" maxOccurs="1" />
          <xsd:element name="translation" type="ED" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="mediaType" type="xsd:string" fixed="text/plain" use="required" />
        <xsd:attribute name="compression" type="Compression" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ST">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no nested translations">
          <sch:rule abstract="true" id="ST-0">
            <sch:assert test="not(translation) or thumbnail[not(translation)]" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="null or content">
          <sch:rule abstract="true" id="ST-1">
            <sch:assert test="(@nullFlavor or (@value and string-length(@value)&#38;gt;0)) and not(@nullFlavor and @value)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="translation" type="ST.NT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="optional" />
        <xsd:attribute name="language" type="Code" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ST.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="ST.NT-0">
            <sch:assert test="not(translation)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ST">
        <xsd:sequence>
          <xsd:element name="translation" type="ST.NT" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.IMAGE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="fixed to image">
          <sch:rule abstract="true" id="ED.IMAGE-0">
            <sch:assert test="starts-with(@mediaType, &#34;image/&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no text">
          <sch:rule abstract="true" id="ED.IMAGE-1">
            <sch:assert test="not(@value)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no xml">
          <sch:rule abstract="true" id="ED.IMAGE-2">
            <sch:assert test="not(xml)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED">
        <xsd:sequence>
          <xsd:element name="data" type="xsd:base64Binary" minOccurs="0" maxOccurs="1" />
          <xsd:element name="xml" type="xsd:anyType" minOccurs="0" maxOccurs="1" />
          <xsd:element name="reference" type="TEL.URL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="integrityCheck" type="xsd:base64Binary" minOccurs="0" maxOccurs="1" />
          <xsd:element name="thumbnail" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="description" type="ST" minOccurs="0" maxOccurs="1" />
          <xsd:element name="translation" type="ED" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="prohibited" />
        <xsd:attribute name="mediaType" type="xsd:string" use="required" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.DOC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="mediaType">
          <sch:rule abstract="true" id="ED.DOC-0">
            <sch:assert test="mediaType = &#34;text/plain&#34; or mediaType = &#34;text/html&#34; or mediaType = &#34;text/xml&#34; or mediaType = &#34;application/pdf&#34;" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED">
        <xsd:sequence>
          <xsd:element name="data" type="xsd:base64Binary" minOccurs="0" maxOccurs="1" />
          <xsd:element name="xml" type="xsd:anyType" minOccurs="0" maxOccurs="1" />
          <xsd:element name="reference" type="TEL.URL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="integrityCheck" type="xsd:base64Binary" minOccurs="0" maxOccurs="1" />
          <xsd:element name="thumbnail" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="description" type="ST" minOccurs="0" maxOccurs="1" />
          <xsd:element name="translation" type="ED" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="mediaType" type="xsd:string" use="required" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.DOC.REF">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="reference required">
          <sch:rule abstract="true" id="ED.DOC.REF-0">
            <sch:assert test="not(@nullFlavor) or (reference and not(reference/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED.DOC">
        <xsd:sequence>
          <xsd:element name="data" type="xsd:base64Binary" minOccurs="0" maxOccurs="0" />
          <xsd:element name="xml" type="xsd:anyType" minOccurs="0" maxOccurs="0" />
          <xsd:element name="reference" type="TEL.URL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="integrityCheck" type="xsd:base64Binary" minOccurs="0" maxOccurs="1" />
          <xsd:element name="thumbnail" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="description" type="ST" minOccurs="0" maxOccurs="1" />
          <xsd:element name="translation" type="ED" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="prohibited" />
        <xsd:attribute name="mediaType" type="xsd:string" use="required" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.DOC.INLINE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no reference">
          <sch:rule abstract="true" id="ED.DOC.INLINE-0">
            <sch:assert test="not(reference)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED.DOC">
        <xsd:sequence>
          <xsd:element name="data" type="xsd:base64Binary" minOccurs="0" maxOccurs="1" />
          <xsd:element name="xml" type="xsd:anyType" minOccurs="0" maxOccurs="1" />
          <xsd:element name="reference" type="TEL.URL" minOccurs="0" maxOccurs="0" />
          <xsd:element name="integrityCheck" type="xsd:base64Binary" minOccurs="0" maxOccurs="1" />
          <xsd:element name="thumbnail" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="description" type="ST" minOccurs="0" maxOccurs="1" />
          <xsd:element name="translation" type="ED" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="mediaType" type="xsd:string" use="required" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.SIGNATURE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no reference">
          <sch:rule abstract="true" id="ED.SIGNATURE-0">
            <sch:assert test="not(reference)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no value">
          <sch:rule abstract="true" id="ED.SIGNATURE-1">
            <sch:assert test="not(@value)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no data">
          <sch:rule abstract="true" id="ED.SIGNATURE-2">
            <sch:assert test="not(data)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no integrityCheck">
          <sch:rule abstract="true" id="ED.SIGNATURE-3">
            <sch:assert test="not(integrityCheck)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no thumbnail">
          <sch:rule abstract="true" id="ED.SIGNATURE-4">
            <sch:assert test="not(thumbnail)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no compression">
          <sch:rule abstract="true" id="ED.SIGNATURE-5">
            <sch:assert test="not(@compression)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no language">
          <sch:rule abstract="true" id="ED.SIGNATURE-6">
            <sch:assert test="not(@language)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="mediaType">
          <sch:rule abstract="true" id="ED.SIGNATURE-7">
            <sch:assert test="@mediaType = &#34;&#39;text/xml&#39;&#34;" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="ED.SIGNATURE-8">
            <sch:assert test="not(translation)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED">
        <xsd:sequence>
          <xsd:element name="data" type="xsd:base64Binary" minOccurs="0" maxOccurs="0" />
          <xsd:element name="xml" type="xsd:anyType" minOccurs="0" maxOccurs="1" />
          <xsd:element name="reference" type="TEL.URL" minOccurs="0" maxOccurs="0" />
          <xsd:element name="integrityCheck" type="xsd:base64Binary" minOccurs="0" maxOccurs="0" />
          <xsd:element name="thumbnail" type="ED" minOccurs="0" maxOccurs="0" />
          <xsd:element name="description" type="ST" minOccurs="0" maxOccurs="1" />
          <xsd:element name="translation" type="ED" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="prohibited" />
        <xsd:attribute name="mediaType" type="xsd:string" fixed="text/xml" use="required" />
        <xsd:attribute name="language" type="Code" use="prohibited" />
        <xsd:attribute name="compression" type="Compression" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.STRUCTUREDTEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="mediatype">
          <sch:rule abstract="true" id="ED.STRUCTUREDTEXT-0">
            <sch:assert test="@mediaType = &#34;&#39;text/x-hl7-text+xml&#39;&#34;" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no value">
          <sch:rule abstract="true" id="ED.STRUCTUREDTEXT-1">
            <sch:assert test="not(@value)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no data">
          <sch:rule abstract="true" id="ED.STRUCTUREDTEXT-2">
            <sch:assert test="not(data)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="ED.STRUCTUREDTEXT-3">
            <sch:assert test="not(translation)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED">
        <xsd:sequence>
          <xsd:element name="data" type="xsd:base64Binary" minOccurs="0" maxOccurs="0" />
          <xsd:element name="xml" type="StrucDoc.Text" minOccurs="0" maxOccurs="1" />
          <xsd:element name="reference" type="TEL.URL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="integrityCheck" type="xsd:base64Binary" minOccurs="0" maxOccurs="1" />
          <xsd:element name="thumbnail" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="description" type="ST" minOccurs="0" maxOccurs="1" />
          <xsd:element name="translation" type="ED" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="prohibited" />
        <xsd:attribute name="mediaType" type="xsd:string" fixed="text/x-hl7-text+xml" use="required" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ED.STRUCTUREDTITLE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="mediatype">
          <sch:rule abstract="true" id="ED.STRUCTUREDTITLE-0">
            <sch:assert test="@mediaType = &#34;&#39;text/x-hl7-text+xml&#39;&#34;" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no value">
          <sch:rule abstract="true" id="ED.STRUCTUREDTITLE-1">
            <sch:assert test="not(@value)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no data">
          <sch:rule abstract="true" id="ED.STRUCTUREDTITLE-2">
            <sch:assert test="not(data)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="ED.STRUCTUREDTITLE-3">
            <sch:assert test="not(translation)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="ED">
        <xsd:sequence>
          <xsd:element name="data" type="xsd:base64Binary" minOccurs="0" maxOccurs="0" />
          <xsd:element name="xml" type="StrucDoc.Title" minOccurs="0" maxOccurs="1" />
          <xsd:element name="reference" type="TEL.URL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="integrityCheck" type="xsd:base64Binary" minOccurs="0" maxOccurs="1" />
          <xsd:element name="thumbnail" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="description" type="ST" minOccurs="0" maxOccurs="1" />
          <xsd:element name="translation" type="ED" minOccurs="0" maxOccurs="0" />
          <xsd:element name="xml" type="StrucDoc.Title" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:string" use="prohibited" />
        <xsd:attribute name="mediaType" type="xsd:string" fixed="text/x-hl7-text+xml" use="required" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.Title">
    <xsd:sequence>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element name="footnote" type="StrucDoc.TitleFootnote" />
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
        <xsd:element name="br" type="StrucDoc.Br" />
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml" />
        <xsd:element name="sub" type="StrucDoc.Sub" />
        <xsd:element name="sup" type="StrucDoc.Sup" />
        <xsd:element name="content" type="StrucDoc.CMTitle" />
      </xsd:choice>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.TitleFootnote">
    <xsd:sequence>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element name="footnote" type="StrucDoc.TitleFootnote" />
        <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" />
        <xsd:element name="br" type="StrucDoc.Br" />
        <xsd:element name="linkHtml" type="StrucDoc.LinkHtml" />
        <xsd:element name="sub" type="StrucDoc.Sub" />
        <xsd:element name="sup" type="StrucDoc.Sup" />
        <xsd:element name="content" type="StrucDoc.CMTitle" />
      </xsd:choice>
    </xsd:sequence>
    <xsd:attributeGroup ref="StrucDoc.Base" />
  </xsd:complexType>
  <xsd:complexType mixed="true" name="StrucDoc.CMTitle">
    <xsd:sequence>
      <xsd:element name="footnote" type="StrucDoc.TitleFootnote" minOccurs="0" maxOccurs="1" />
      <xsd:element name="footnoteRef" type="StrucDoc.FootnoteRef" minOccurs="0" maxOccurs="1" />
      <xsd:element name="br" type="StrucDoc.Br" minOccurs="0" maxOccurs="1" />
      <xsd:element name="linkHtml" type="StrucDoc.LinkHtml" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sub" type="StrucDoc.Sub" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sup" type="StrucDoc.Sup" minOccurs="0" maxOccurs="1" />
      <xsd:element name="content" type="StrucDoc.CMTitle" minOccurs="0" maxOccurs="1" />
    </xsd:sequence>
  </xsd:complexType>
  <xsd:complexType name="SC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no code if no value">
          <sch:rule abstract="true" id="SC-0">
            <sch:assert test="not(@nullFlavor) or (not(code) or (code/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SC attributes">
          <sch:rule abstract="true" id="SC-1">
            <sch:assert test="count(*[self::code][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no originalText">
          <sch:rule abstract="true" id="SC-2">
            <sch:assert test="(not(originalText) or not(oroginalText/@nullFlavor)) or (not(code) or (code/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ST">
        <xsd:sequence>
          <xsd:element name="code" type="CD" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or code and/or originalText">
          <sch:rule abstract="true" id="CD-0">
            <sch:assert test="@nullFlavor or @code or (originalText and not(originalText/@nullFlavor) or (originalTextReference and not(originalTextReference/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="other requires codeSystem or valueSet">
          <sch:rule abstract="true" id="CD-1">
            <sch:assert test="@nullFlavor != &#34;OTH&#34; or @codeSystem or @valueSet" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="code requires codeSystem">
          <sch:rule abstract="true" id="CD-2">
            <sch:assert test="@codeSystem or not(@code)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="codeSystemName only if codeSystem">
          <sch:rule abstract="true" id="CD-3">
            <sch:assert test="@codeSystem or not(@codeSystemName)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="codeSystemVersion only if codeSystem">
          <sch:rule abstract="true" id="CD-4">
            <sch:assert test="@codeSystem or not(@codeSystemVersion)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="displayName only if code">
          <sch:rule abstract="true" id="CD-5">
            <sch:assert test="@code or not(@displayName)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="valueSet requires valueSetVersion">
          <sch:rule abstract="true" id="CD-6">
            <sch:assert test="not(@valueSet) or (@valueSet and @valueSetVersion)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No original text on translations">
          <sch:rule abstract="true" id="CD-7">
            <sch:assert test="not translation/originalText" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="Translations cannot have translations">
          <sch:rule abstract="true" id="CD-8">
            <sch:assert test="not translation/translation" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on CD elements">
          <sch:rule abstract="true" id="CD-9">
            <sch:assert test="count(*[self::displayName or self::originalText or self::originalTextReference or self::translation][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no code if null">
          <sch:rule abstract="true" id="CD-10">
            <sch:assert test="not(@nullFlavor) or (not(thumbnail) or code\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no displayName if null">
          <sch:rule abstract="true" id="CD-11">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@displayName))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no source if null">
          <sch:rule abstract="true" id="CD-12">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@source))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="displayName" type="ST" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="translation" type="CD" minOccurs="0" maxOccurs="unbounded" />
          <xsd:element name="source" type="XReference" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="code" type="xsd:string" use="optional" />
        <xsd:attribute name="codeSystem" type="Uid" use="optional" />
        <xsd:attribute name="codeSystemName" type="xsd:string" use="optional" />
        <xsd:attribute name="codeSystemVersion" type="xsd:string" use="optional" />
        <xsd:attribute name="valueSet" type="xsd:string" use="optional" />
        <xsd:attribute name="valueSetVersion" type="xsd:string" use="optional" />
        <xsd:attribute name="codingRationale" type="set_CodingRationale" use="optional" />
        <xsd:attribute name="id" type="xsd:ID" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="XReference">
    <xsd:attribute name="xref" type="xsd:IDREF" use="required" />
  </xsd:complexType>
  <xsd:complexType name="SC.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="SC.NT-0">
            <sch:assert test="not(translation)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="SC">
        <xsd:sequence>
          <xsd:element name="translation" type="ST.NT" minOccurs="0" maxOccurs="0" />
          <xsd:element name="code" type="CD" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TEL.EMAIL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="email only">
          <sch:rule abstract="true" id="TEL.EMAIL-0">
            <sch:assert test="starts-with(@value, &#34;mailto&#34;)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="TEL.PERSON">
        <xsd:sequence>
          <xsd:element name="useablePeriod" type="QSET_TS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TEL.PERSON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="Personal Address">
          <sch:rule abstract="true" id="TEL.PERSON-0">
            <sch:assert test="starts-with(@value, &#34;tel&#34;) or starts-with(@value, &#34;x-text-fax&#34;) or starts-with(@value, &#34;x-text-tel&#34;) or starts-with(@value, &#34;mailto&#34;)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="TEL">
        <xsd:sequence>
          <xsd:element name="useablePeriod" type="QSET_TS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TEL.PHONE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="Phone">
          <sch:rule abstract="true" id="TEL.PHONE-0">
            <sch:assert test="starts-with(@value, &#34;tel&#34;) or starts-with(@value, &#34;x-text-fax&#34;) or starts-with(@value, &#34;x-text-tel&#34;)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="TEL.PERSON">
        <xsd:sequence>
          <xsd:element name="useablePeriod" type="QSET_TS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="II">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="root is required">
          <sch:rule abstract="true" id="II-0">
            <sch:assert test="@nullFlavor or (not(@nullFlavor) and @root)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no root if null">
          <sch:rule abstract="true" id="II-1">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@root))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no extension if null">
          <sch:rule abstract="true" id="II-2">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@extension))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no identifierName if null">
          <sch:rule abstract="true" id="II-3">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@identifierName))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no displayable if null">
          <sch:rule abstract="true" id="II-4">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@displayable))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no reliability if null">
          <sch:rule abstract="true" id="II-5">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@reliability))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:attribute name="root" type="Uid" use="optional" />
        <xsd:attribute name="extension" type="xsd:string" use="optional" />
        <xsd:attribute name="identifierName" type="xsd:string" use="optional" />
        <xsd:attribute name="displayable" type="xsd:boolean" use="optional" />
        <xsd:attribute name="scope" type="IdentifierScope" use="optional" />
        <xsd:attribute name="reliability" type="IdentifierReliability" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CD.CV">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no translations">
          <sch:rule abstract="true" id="CD.CV-0">
            <sch:assert test="not(translation)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no source">
          <sch:rule abstract="true" id="CD.CV-1">
            <sch:assert test="not(@source)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="CD">
        <xsd:sequence>
          <xsd:element name="displayName" type="ST" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="translation" type="CD" minOccurs="0" maxOccurs="0" />
          <xsd:element name="source" type="XReference" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have a code or a value">
          <sch:rule abstract="true" id="CO-0">
            <sch:assert test="@nullFlavor or (@value or (code and not(code/@nullFlavor)))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="CO-1">
            <sch:assert test="count(*[self::code][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no value if null">
          <sch:rule abstract="true" id="CO-2">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@value))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no code if null">
          <sch:rule abstract="true" id="CO-3">
            <sch:assert test="not(@nullFlavor) or (not code or code/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="code" type="CD" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QTY">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="uncertainty">
          <sch:rule abstract="true" id="QTY-0">
            <sch:assert test="not(uncertainty/@expression) and not(uncertainty/@uncertainty) and not(uncertainty/@originalText)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QTY-1">
            <sch:assert test="count(*[self::originalText or self::uncertainty or self::expression][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="uncertaintyType" type="UncertaintyType" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="CS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="code is required">
          <sch:rule abstract="true" id="CS-0">
            <sch:assert test="@nullFlavor or (not(@nullFlavor) and @code)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no code if null">
          <sch:rule abstract="true" id="CS-1">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@code))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:attribute name="code" type="xsd:string" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="AD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or parts">
          <sch:rule abstract="true" id="AD-0">
            <sch:assert test="(@nullFlavor or part) and not(@nullFlavor and part)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no useablePeriod if null">
          <sch:rule abstract="true" id="AD-1">
            <sch:assert test="not(@nullFlavor) or (not(thumbnail) or useablePeriod\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on AD attributes">
          <sch:rule abstract="true" id="AD-2">
            <sch:assert test="count(*[self::useablePeriod][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:choice minOccurs="0" maxOccurs="unbounded">
            <xsd:element name="part" type="ADXP" />
            <xsd:element name="br" type="ADXP.BR" />
            <xsd:element name="addressLine" type="ADXP.AL" />
            <xsd:element name="additionalLocator" type="ADXP.ADL" />
            <xsd:element name="unitID" type="ADXP.UNID" />
            <xsd:element name="unitType" type="ADXP.UNIT" />
            <xsd:element name="deliveryAddressLine" type="ADXP.DAL" />
            <xsd:element name="deliveryInstallationType" type="ADXP.DINST" />
            <xsd:element name="deliveryInstallationArea" type="ADXP.DINSTA" />
            <xsd:element name="deliveryInstallationQualifier" type="ADXP.DINSTQ" />
            <xsd:element name="deliveryMode" type="ADXP.DMOD" />
            <xsd:element name="deliveryModeIdentifier" type="ADXP.DMODID" />
            <xsd:element name="streetAddressLine" type="ADXP.SAL" />
            <xsd:element name="houseNumber" type="ADXP.BNR" />
            <xsd:element name="houseNumberNumeric" type="ADXP.BNN" />
            <xsd:element name="buildingNumberSuffix" type="ADXP.BNS" />
            <xsd:element name="streetName" type="ADXP.STR" />
            <xsd:element name="streetNameBase" type="ADXP.STB" />
            <xsd:element name="streetType" type="ADXP.STTYP" />
            <xsd:element name="intersection" type="ADXP.INT" />
            <xsd:element name="direction" type="ADXP.DIR" />
            <xsd:element name="careOf" type="ADXP.CAR" />
            <xsd:element name="censusTract" type="ADXP.CEN" />
            <xsd:element name="country" type="ADXP.CNT" />
            <xsd:element name="county" type="ADXP.CPA" />
            <xsd:element name="city" type="ADXP.CTY" />
            <xsd:element name="postBox" type="ADXP.POB" />
            <xsd:element name="precinct" type="ADXP.PRE" />
            <xsd:element name="state" type="ADXP.STA" />
            <xsd:element name="postalCode" type="ADXP.ZIP" />
          </xsd:choice>
          <xsd:element name="useablePeriod" type="QSET_TS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="use" type="set_PostalAddressUse" use="optional" />
        <xsd:attribute name="isNotOrdered" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType mixed="true" name="ADXP">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value is required">
          <sch:rule abstract="true" id="ADXP-0">
            <sch:assert test="string-length(@value) &#62; 0" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="code requires codeSystem">
          <sch:rule abstract="true" id="ADXP-1">
            <sch:assert test="@codeSystem or not(@code)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="codeSystemVersion only if codeSystem">
          <sch:rule abstract="true" id="ADXP-2">
            <sch:assert test="@codeSystem or not(@codeSystemVersion)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute name="code" type="xsd:string" use="optional" />
    <xsd:attribute name="codeSystem" type="xsd:string" use="optional" />
    <xsd:attribute name="codeSystemVersion" type="xsd:string" use="optional" />
    <xsd:attribute name="language" type="Code" use="optional" />
    <xsd:attribute name="type" type="AddressPartType" use="optional" />
  </xsd:complexType>
  <xsd:complexType name="ADXP.BR">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="DEL" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.AL">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="AL" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.ADL">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="ADL" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.UNID">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="UNID" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.UNIT">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="UNIT" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DAL">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="DAL" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DINST">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="DINST" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DINSTA">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="DINSTA" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DINSTQ">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="DINSTQ" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DMOD">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="DMOD" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DMODID">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="DMODID" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.SAL">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="SAL" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.BNR">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="BNR" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.BNN">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="BNN" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.BNS">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="BNS" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.STR">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="STR" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.STB">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="STB" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.STTYP">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="STTYP" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.INT">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="INT" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.DIR">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="DIR" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.CAR">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="CAR" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.CEN">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="CEN" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.CNT">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="CNT" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.CPA">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="CPA" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.CTY">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="CTY" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.POB">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="POB" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.PRE">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="PRE" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.STA">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="STA" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ADXP.ZIP">
    <xsd:complexContent>
      <xsd:restriction base="ADXP">
        <xsd:attribute name="type" type="AddressPartType" fixed="ZIP" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or parts">
          <sch:rule abstract="true" id="EN-0">
            <sch:assert test="(@nullFlavor or part) and not(@nullFlavor and part)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="part" type="ENXP" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="use" type="set_EntityNameUse" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="ENXP">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value is required">
          <sch:rule abstract="true" id="ENXP-0">
            <sch:assert test="string-length(@value) &#62; 0" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="code requires codeSystem">
          <sch:rule abstract="true" id="ENXP-1">
            <sch:assert test="@codeSystem or not(@code)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="codeSystemVersion only if codeSystem">
          <sch:rule abstract="true" id="ENXP-2">
            <sch:assert test="@codeSystem or not(@codeSystemVersion)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:attribute name="value" type="xsd:string" use="optional" />
    <xsd:attribute name="code" type="xsd:string" use="optional" />
    <xsd:attribute name="codeSystem" type="xsd:string" use="optional" />
    <xsd:attribute name="codeSystemVersion" type="xsd:string" use="optional" />
    <xsd:attribute name="language" type="Code" use="optional" />
    <xsd:attribute name="type" type="EntityNamePartType" use="optional" />
    <xsd:attribute name="qualifier" type="set_EntityNamePartQualifier" use="optional" />
  </xsd:complexType>
  <xsd:complexType name="EN.TN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="only one part with no type">
          <sch:rule abstract="true" id="EN.TN-0">
            <sch:assert test="@nullFlavor or (count(part) = 1 and not part/@type)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="EN" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EN.PN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no parts are qualified by LS">
          <sch:rule abstract="true" id="EN.PN-0">
            <sch:assert test="count(part[contains(@qualifier, &#39;LS&#39;)])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="EN" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EN.ON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no parts are person types">
          <sch:rule abstract="true" id="EN.ON-0">
            <sch:assert test="count(part[type = &#39;FAM&#39; or type = &#39;GIV&#39;])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="EN" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="TS-0">
            <sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:attribute name="value" use="optional">
          <xsd:simpleType>
            <xsd:restriction base="xsd:string">
              <xsd:pattern value="[1-2][0-9]{3,3}(((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9]|3[0-1])(([0-1][0-9]|2[0-3])([0-5][0-9]([0-5][0-9](\.[0-9]{1,4})?)?)?)?)?)?([+\-](0[0-9]|1[0-3])([0-5][0-9]))?" />
            </xsd:restriction>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS.DATE">
    <xsd:complexContent>
      <xsd:restriction base="TS">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="value" use="optional">
          <xsd:simpleType>
            <xsd:restriction base="xsd:string">
              <xsd:pattern value="[1-2][0-9]{3,3}((0[1-9])|(1[0-2])((0[1-9])|([1-2][0-9]|3[0-1]))?)?" />
            </xsd:restriction>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS.DATE.FULL">
    <xsd:complexContent>
      <xsd:restriction base="TS.DATE">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="value" use="optional">
          <xsd:simpleType>
            <xsd:restriction base="xsd:string">
              <xsd:pattern value="[1-2][0-9]{3,3}(0[1-9])|(1[0-2]))(0[1-9])|([1-2][0-9]|3[0-1])" />
            </xsd:restriction>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS.DATETIME">
    <xsd:complexContent>
      <xsd:restriction base="TS">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="value" use="optional">
          <xsd:simpleType>
            <xsd:restriction base="xsd:string">
              <xsd:pattern value="[1-2][0-9]{3,3}(((0[1-9])|(1[0-2]))((0[1-9])|([1-2][0-9]|3[0-1])(([0-1][0-9]|2[0-3])([0-5][0-9]([0-5][0-9])?)?)?)?)?([+\-](0[0-9]|1[0-3])([0-5][0-9]))?" />
            </xsd:restriction>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS.DATETIME.FULL">
    <xsd:complexContent>
      <xsd:restriction base="TS.DATETIME">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="value" use="optional">
          <xsd:simpleType>
            <xsd:restriction base="xsd:string">
              <xsd:pattern value="[1-2][0-9]{3,3}(0[1-9])|(1[0-2])(0[1-9])|([1-2][0-9]|3[0-1])([0-1][0-9]|2[0-3])[0-5][0-9][0-5][0-9]([+\-](0[0-9]|1[0-3])([0-5][0-9]))?" />
            </xsd:restriction>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="TS.BIRTH">
    <xsd:complexContent>
      <xsd:restriction base="TS">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="value" use="optional">
          <xsd:simpleType>
            <xsd:restriction base="xsd:string">
              <xsd:pattern value="[1-2][0-9]{3,3}(((0[1-9])|(1[0-2]))(0[1-9])|([1-2][0-9]|3[0-1])(([0-1][0-9]|2[0-3])([0-5][0-9]([0-5][0-9]))[+\-](0[0-9]|1[0-3])([0-5][0-9]))?)?" />
            </xsd:restriction>
          </xsd:simpleType>
        </xsd:attribute>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="numerator and denominator required">
          <sch:rule abstract="true" id="RTO-0">
            <sch:assert test="@nullFlavor or ((numerator and not(numerator/@nullFlavor)) and (numerator and not(numerator/@nullFlavor)))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on RTO Attributes">
          <sch:rule abstract="true" id="RTO-1">
            <sch:assert test="count(*[self::numerator or self::denominator][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no uncertainty">
          <sch:rule abstract="true" id="RTO-2">
            <sch:assert test="not(uncertainty)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="numerator" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="denominator" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="MO-0">
            <sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="null or currency">
          <sch:rule abstract="true" id="MO-1">
            <sch:assert test="(@nullFlavor or @currency) and not(@nullFlavor and @currency)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no precision if null">
          <sch:rule abstract="true" id="MO-2">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@precision))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:attribute name="value" type="xsd:double" use="optional" />
        <xsd:attribute name="precision" type="xsd:int" use="optional" />
        <xsd:attribute name="currency" type="Code" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no translation if null">
          <sch:rule abstract="true" id="PQ-0">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@translation))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="PQV">
        <xsd:sequence>
          <xsd:element name="translation" type="PQR" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
        <xsd:attribute name="unit" type="Code" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PQV">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="PQV-0">
            <sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no precision if null">
          <sch:rule abstract="true" id="PQV-1">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@precision))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="source" type="XReference" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="value" type="xsd:double" use="optional" />
        <xsd:attribute name="precision" type="xsd:int" default="0" use="optional" />
        <xsd:attribute name="codingRationale" type="set_CodingRationale" use="optional" />
        <xsd:attribute name="id" type="xsd:ID" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PQR">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or unit">
          <sch:rule abstract="true" id="PQR-0">
            <sch:assert test="todo" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no originalText">
          <sch:rule abstract="true" id="PQR-1">
            <sch:assert test="not(@originalText)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PQR">
          <sch:rule abstract="true" id="PQR-2">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not(@controlActRoot) and not(@controlActExtension) and not(@updateMode)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="PQV">
        <xsd:sequence>
          <xsd:element name="unit" type="CD.CV" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PQ.TIME">
    <xsd:complexContent>
      <xsd:restriction base="PQ">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="source" type="XReference" minOccurs="0" maxOccurs="1" />
          <xsd:element name="translation" type="PQR" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="REAL-0">
            <sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no precision if null">
          <sch:rule abstract="true" id="REAL-1">
            <sch:assert test="not(@nullFlavor) or (@nullFlavor and not(@precision))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:attribute name="value" type="xsd:double" use="optional" />
        <xsd:attribute name="precision" type="xsd:int" default="0" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no uncertainty">
          <sch:rule abstract="true" id="INT-0">
            <sch:assert test="not(uncertainty)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="null or value">
          <sch:rule abstract="true" id="INT-1">
            <sch:assert test="(@nullFlavor or @value) and not(@nullFlavor and @value)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:attribute name="value" type="xsd:int" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not negative">
          <sch:rule abstract="true" id="INT.NONNEG-0">
            <sch:assert test="(@nullFlavor) or (@value &#62;= 0)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="INT">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="INT.POS">
    <xsd:complexContent>
      <xsd:restriction base="INT.NONNEG">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_BL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_BL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_BL">
        <xsd:sequence>
          <xsd:element name="item" type="BL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_BL">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_BL.NONNULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_BL.NONNULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_BL.NONNULL">
        <xsd:sequence>
          <xsd:element name="item" type="BL.NONNULL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_BL.NONNULL">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED">
        <xsd:sequence>
          <xsd:element name="item" type="ED" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.IMAGE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.IMAGE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.IMAGE">
        <xsd:sequence>
          <xsd:element name="item" type="ED.IMAGE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.IMAGE">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.TEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.TEXT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.TEXT">
        <xsd:sequence>
          <xsd:element name="item" type="ED.TEXT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.TEXT">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.DOC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.DOC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.DOC">
        <xsd:sequence>
          <xsd:element name="item" type="ED.DOC" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.DOC">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.DOC.REF">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.DOC.REF-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.DOC.REF">
        <xsd:sequence>
          <xsd:element name="item" type="ED.DOC.REF" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.DOC.REF">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.DOC.INLINE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.DOC.INLINE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.DOC.INLINE">
        <xsd:sequence>
          <xsd:element name="item" type="ED.DOC.INLINE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.DOC.INLINE">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.SIGNATURE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.SIGNATURE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.SIGNATURE">
        <xsd:sequence>
          <xsd:element name="item" type="ED.SIGNATURE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.SIGNATURE">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.STRUCTUREDTEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.STRUCTUREDTEXT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.STRUCTUREDTEXT">
        <xsd:sequence>
          <xsd:element name="item" type="ED.STRUCTUREDTEXT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.STRUCTUREDTEXT">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ED.STRUCTUREDTITLE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ED.STRUCTUREDTITLE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.STRUCTUREDTITLE">
        <xsd:sequence>
          <xsd:element name="item" type="ED.STRUCTUREDTITLE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ED.STRUCTUREDTITLE">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ST">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ST-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ST">
        <xsd:sequence>
          <xsd:element name="item" type="ST" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ST">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_ST.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_ST.NT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_ST.NT">
        <xsd:sequence>
          <xsd:element name="item" type="ST.NT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_ST.NT">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_SC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_SC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_SC">
        <xsd:sequence>
          <xsd:element name="item" type="SC" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_SC">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_SC.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_SC.NT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_SC.NT">
        <xsd:sequence>
          <xsd:element name="item" type="SC.NT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_SC.NT">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TEL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TEL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL">
        <xsd:sequence>
          <xsd:element name="item" type="TEL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TEL">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TEL.EMAIL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TEL.EMAIL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.EMAIL">
        <xsd:sequence>
          <xsd:element name="item" type="TEL.EMAIL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TEL.EMAIL">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TEL.PERSON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TEL.PERSON-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.PERSON">
        <xsd:sequence>
          <xsd:element name="item" type="TEL.PERSON" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TEL.PERSON">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TEL.PHONE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TEL.PHONE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.PHONE">
        <xsd:sequence>
          <xsd:element name="item" type="TEL.PHONE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TEL.PHONE">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TEL.URL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TEL.URL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.URL">
        <xsd:sequence>
          <xsd:element name="item" type="TEL.URL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TEL.URL">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_II">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_II-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_II">
        <xsd:sequence>
          <xsd:element name="item" type="II" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_II">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_CD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_CD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CD">
        <xsd:sequence>
          <xsd:element name="item" type="CD" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_CD">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_CD.CV">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_CD.CV-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CD.CV">
        <xsd:sequence>
          <xsd:element name="item" type="CD.CV" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_CD.CV">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_CO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CO">
        <xsd:sequence>
          <xsd:element name="item" type="CO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_CO">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_CS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_CS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_CS">
        <xsd:sequence>
          <xsd:element name="item" type="CS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_CS">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_AD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_AD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_AD">
        <xsd:sequence>
          <xsd:element name="item" type="AD" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_AD">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_EN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_EN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_EN">
        <xsd:sequence>
          <xsd:element name="item" type="EN" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_EN">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_EN.TN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_EN.TN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_EN.TN">
        <xsd:sequence>
          <xsd:element name="item" type="EN.TN" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_EN.TN">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_EN.PN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_EN.PN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_EN.PN">
        <xsd:sequence>
          <xsd:element name="item" type="EN.PN" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_EN.PN">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_EN.ON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_EN.ON-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_EN.ON">
        <xsd:sequence>
          <xsd:element name="item" type="EN.ON" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_EN.ON">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS">
        <xsd:sequence>
          <xsd:element name="item" type="TS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TS.DATE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATE">
        <xsd:sequence>
          <xsd:element name="item" type="TS.DATE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS.DATE">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TS.DATE.FULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element name="item" type="TS.DATE.FULL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS.DATE.FULL">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TS.DATETIME-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATETIME">
        <xsd:sequence>
          <xsd:element name="item" type="TS.DATETIME" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS.DATETIME">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TS.DATETIME.FULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element name="item" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS.DATETIME.FULL">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_TS.BIRTH-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.BIRTH">
        <xsd:sequence>
          <xsd:element name="item" type="TS.BIRTH" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_TS.BIRTH">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_RTO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_RTO">
        <xsd:sequence>
          <xsd:element name="item" type="RTO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_RTO">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_MO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_MO">
        <xsd:sequence>
          <xsd:element name="item" type="MO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_MO">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_PQ-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_PQ">
        <xsd:sequence>
          <xsd:element name="item" type="PQ" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_PQ">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_PQ.TIME-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_PQ.TIME">
        <xsd:sequence>
          <xsd:element name="item" type="PQ.TIME" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_PQ.TIME">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_REAL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_REAL">
        <xsd:sequence>
          <xsd:element name="item" type="REAL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_REAL">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_INT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_INT">
        <xsd:sequence>
          <xsd:element name="item" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_INT">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_INT.NONNEG-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_INT.NONNEG">
        <xsd:sequence>
          <xsd:element name="item" type="INT.NONNEG" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_INT.NONNEG">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="DSET_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="DSET_INT.POS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="COLL_INT.POS">
        <xsd:sequence>
          <xsd:element name="item" type="INT.POS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="COLL_INT.POS">
    <xsd:complexContent>
      <xsd:extension base="ANY" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_BL">
    <xsd:complexContent>
      <xsd:extension base="COLL_BL">
        <xsd:sequence>
          <xsd:element name="item" type="BL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_BL.NONNULL">
    <xsd:complexContent>
      <xsd:extension base="COLL_BL.NONNULL">
        <xsd:sequence>
          <xsd:element name="item" type="BL.NONNULL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED">
        <xsd:sequence>
          <xsd:element name="item" type="ED" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.IMAGE">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.IMAGE">
        <xsd:sequence>
          <xsd:element name="item" type="ED.IMAGE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.TEXT">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.TEXT">
        <xsd:sequence>
          <xsd:element name="item" type="ED.TEXT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.DOC">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.DOC">
        <xsd:sequence>
          <xsd:element name="item" type="ED.DOC" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.DOC.REF">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.DOC.REF">
        <xsd:sequence>
          <xsd:element name="item" type="ED.DOC.REF" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.DOC.INLINE">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.DOC.INLINE">
        <xsd:sequence>
          <xsd:element name="item" type="ED.DOC.INLINE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.SIGNATURE">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.SIGNATURE">
        <xsd:sequence>
          <xsd:element name="item" type="ED.SIGNATURE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.STRUCTUREDTEXT">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.STRUCTUREDTEXT">
        <xsd:sequence>
          <xsd:element name="item" type="ED.STRUCTUREDTEXT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ED.STRUCTUREDTITLE">
    <xsd:complexContent>
      <xsd:extension base="COLL_ED.STRUCTUREDTITLE">
        <xsd:sequence>
          <xsd:element name="item" type="ED.STRUCTUREDTITLE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ST">
    <xsd:complexContent>
      <xsd:extension base="COLL_ST">
        <xsd:sequence>
          <xsd:element name="item" type="ST" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_ST.NT">
    <xsd:complexContent>
      <xsd:extension base="COLL_ST.NT">
        <xsd:sequence>
          <xsd:element name="item" type="ST.NT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_SC">
    <xsd:complexContent>
      <xsd:extension base="COLL_SC">
        <xsd:sequence>
          <xsd:element name="item" type="SC" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_SC.NT">
    <xsd:complexContent>
      <xsd:extension base="COLL_SC.NT">
        <xsd:sequence>
          <xsd:element name="item" type="SC.NT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TEL">
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL">
        <xsd:sequence>
          <xsd:element name="item" type="TEL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TEL.EMAIL">
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.EMAIL">
        <xsd:sequence>
          <xsd:element name="item" type="TEL.EMAIL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TEL.PERSON">
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.PERSON">
        <xsd:sequence>
          <xsd:element name="item" type="TEL.PERSON" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TEL.PHONE">
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.PHONE">
        <xsd:sequence>
          <xsd:element name="item" type="TEL.PHONE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TEL.URL">
    <xsd:complexContent>
      <xsd:extension base="COLL_TEL.URL">
        <xsd:sequence>
          <xsd:element name="item" type="TEL.URL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_II">
    <xsd:complexContent>
      <xsd:extension base="COLL_II">
        <xsd:sequence>
          <xsd:element name="item" type="II" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_CD">
    <xsd:complexContent>
      <xsd:extension base="COLL_CD">
        <xsd:sequence>
          <xsd:element name="item" type="CD" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_CD.CV">
    <xsd:complexContent>
      <xsd:extension base="COLL_CD.CV">
        <xsd:sequence>
          <xsd:element name="item" type="CD.CV" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_CO">
    <xsd:complexContent>
      <xsd:extension base="COLL_CO">
        <xsd:sequence>
          <xsd:element name="item" type="CO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_CS">
    <xsd:complexContent>
      <xsd:extension base="COLL_CS">
        <xsd:sequence>
          <xsd:element name="item" type="CS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_AD">
    <xsd:complexContent>
      <xsd:extension base="COLL_AD">
        <xsd:sequence>
          <xsd:element name="item" type="AD" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_EN">
    <xsd:complexContent>
      <xsd:extension base="COLL_EN">
        <xsd:sequence>
          <xsd:element name="item" type="EN" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_EN.TN">
    <xsd:complexContent>
      <xsd:extension base="COLL_EN.TN">
        <xsd:sequence>
          <xsd:element name="item" type="EN.TN" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_EN.PN">
    <xsd:complexContent>
      <xsd:extension base="COLL_EN.PN">
        <xsd:sequence>
          <xsd:element name="item" type="EN.PN" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_EN.ON">
    <xsd:complexContent>
      <xsd:extension base="COLL_EN.ON">
        <xsd:sequence>
          <xsd:element name="item" type="EN.ON" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS">
    <xsd:complexContent>
      <xsd:extension base="COLL_TS">
        <xsd:sequence>
          <xsd:element name="item" type="TS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS.DATE">
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATE">
        <xsd:sequence>
          <xsd:element name="item" type="TS.DATE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS.DATE.FULL">
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element name="item" type="TS.DATE.FULL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS.DATETIME">
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATETIME">
        <xsd:sequence>
          <xsd:element name="item" type="TS.DATETIME" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS.DATETIME.FULL">
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element name="item" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_TS.BIRTH">
    <xsd:complexContent>
      <xsd:extension base="COLL_TS.BIRTH">
        <xsd:sequence>
          <xsd:element name="item" type="TS.BIRTH" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_RTO">
    <xsd:complexContent>
      <xsd:extension base="COLL_RTO">
        <xsd:sequence>
          <xsd:element name="item" type="RTO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_MO">
    <xsd:complexContent>
      <xsd:extension base="COLL_MO">
        <xsd:sequence>
          <xsd:element name="item" type="MO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_PQ">
    <xsd:complexContent>
      <xsd:extension base="COLL_PQ">
        <xsd:sequence>
          <xsd:element name="item" type="PQ" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_PQ.TIME">
    <xsd:complexContent>
      <xsd:extension base="COLL_PQ.TIME">
        <xsd:sequence>
          <xsd:element name="item" type="PQ.TIME" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_REAL">
    <xsd:complexContent>
      <xsd:extension base="COLL_REAL">
        <xsd:sequence>
          <xsd:element name="item" type="REAL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_INT">
    <xsd:complexContent>
      <xsd:extension base="COLL_INT">
        <xsd:sequence>
          <xsd:element name="item" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_INT.NONNEG">
    <xsd:complexContent>
      <xsd:extension base="COLL_INT.NONNEG">
        <xsd:sequence>
          <xsd:element name="item" type="INT.NONNEG" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="BAG_INT.POS">
    <xsd:complexContent>
      <xsd:extension base="COLL_INT.POS">
        <xsd:sequence>
          <xsd:element name="item" type="INT.POS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_BL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_BL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="BL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_BL.NONNULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_BL.NONNULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="BL.NONNULL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="ED" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.IMAGE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.IMAGE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="ED.IMAGE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.TEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.TEXT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="ED.TEXT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.DOC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.DOC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="ED.DOC" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.DOC.REF">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.DOC.REF-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="ED.DOC.REF" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.DOC.INLINE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.DOC.INLINE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="ED.DOC.INLINE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.SIGNATURE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.SIGNATURE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="ED.SIGNATURE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.STRUCTUREDTEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.STRUCTUREDTEXT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="ED.STRUCTUREDTEXT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ED.STRUCTUREDTITLE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ED.STRUCTUREDTITLE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="ED.STRUCTUREDTITLE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ST">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ST-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="ST" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_ST.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_ST.NT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="ST.NT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_SC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_SC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="SC" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_SC.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_SC.NT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="SC.NT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TEL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TEL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="TEL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TEL.EMAIL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TEL.EMAIL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="TEL.EMAIL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TEL.PERSON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TEL.PERSON-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="TEL.PERSON" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TEL.PHONE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TEL.PHONE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="TEL.PHONE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TEL.URL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TEL.URL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="TEL.URL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_II">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_II-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="II" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_CD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_CD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="CD" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_CD.CV">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_CD.CV-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="CD.CV" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_CO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="CO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_CS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_CS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="CS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_AD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_AD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="AD" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_EN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_EN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="EN" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_EN.TN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_EN.TN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="EN.TN" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_EN.PN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_EN.PN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="EN.PN" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_EN.ON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_EN.ON-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="EN.ON" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="TS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TS.DATE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="TS.DATE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TS.DATE.FULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="TS.DATE.FULL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TS.DATETIME-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="TS.DATETIME" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TS.DATETIME.FULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_TS.BIRTH-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="TS.BIRTH" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_RTO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="RTO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_MO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="MO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_PQ-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="PQ" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_PQ.TIME-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="PQ.TIME" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_REAL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="REAL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_INT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_INT.NONNEG-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="INT.NONNEG" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="LIST_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null or not empty">
          <sch:rule abstract="true" id="LIST_INT.POS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="INT.POS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_CO-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_CO-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_CO-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_CO-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element name="low" type="CO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="CO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="CO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_CO-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element name="low" type="TS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="TS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS.DATE-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS.DATE-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS.DATE-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS.DATE-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element name="low" type="TS.DATE" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.DATE" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="TS.DATE" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS.DATE-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS.DATE.FULL-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS.DATE.FULL-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS.DATE.FULL-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS.DATE.FULL-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element name="low" type="TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS.DATE.FULL-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS.DATETIME-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS.DATETIME-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS.DATETIME-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS.DATETIME-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element name="low" type="TS.DATETIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.DATETIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="TS.DATETIME" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS.DATETIME-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS.DATETIME.FULL-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS.DATETIME.FULL-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS.DATETIME.FULL-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS.DATETIME.FULL-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element name="low" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS.DATETIME.FULL-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_TS.BIRTH-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_TS.BIRTH-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_TS.BIRTH-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_TS.BIRTH-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element name="low" type="TS.BIRTH" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.BIRTH" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="TS.BIRTH" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_TS.BIRTH-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_RTO-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_RTO-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_RTO-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_RTO-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_RTO">
        <xsd:sequence>
          <xsd:element name="low" type="RTO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="RTO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="RTO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_RTO-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_MO-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_MO-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_MO-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_MO-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element name="low" type="MO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="MO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="MO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_MO-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_PQ-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_PQ-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_PQ-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_PQ-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element name="low" type="PQ" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="PQ" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="PQ" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_PQ-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_PQ.TIME-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_PQ.TIME-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_PQ.TIME-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_PQ.TIME-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ.TIME">
        <xsd:sequence>
          <xsd:element name="low" type="PQ.TIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="PQ.TIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="PQ.TIME" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_PQ.TIME-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_REAL-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_REAL-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_REAL-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_REAL-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element name="low" type="REAL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="REAL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="REAL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_REAL-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_INT-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_INT-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_INT-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_INT-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element name="low" type="INT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="INT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="INT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_INT-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_INT.NONNEG-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_INT.NONNEG-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_INT.NONNEG-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_INT.NONNEG-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.NONNEG">
        <xsd:sequence>
          <xsd:element name="low" type="INT.NONNEG" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="INT.NONNEG" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="INT.NONNEG" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_INT.NONNEG-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="null rules">
          <sch:rule abstract="true" id="IVL_INT.POS-0">
            <sch:assert test="(@nullFlavor and not(any|low|high|width)) or (not(@nullFlavor) and (any|low|high|width))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="co-occurence rules">
          <sch:rule abstract="true" id="IVL_INT.POS-1">
            <sch:assert test="(((any and not(any/@nullFlavor)) and not((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor)) or (width and not(width/@nullFlavor)))) or (not(any) or any/@nullFlavor)) and ((any and not(any/@nullFlavor)) or (not(any) or any/@nullFlavor) and (((width and not(width/@nullFlavor)) and (not(low) or low/@nullFlavor) and (not(high) or high/@nullFlavor))) or ((not(width) or width/@nullFlavor) and ((low and not(low/@nullFlavor)) or (high and not(high/@nullFlavor))))))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="closed attributes only if limited">
          <sch:rule abstract="true" id="IVL_INT.POS-2">
            <sch:assert test="not(low and @lowClosed) and not(high and @highClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on IVL attributes">
          <sch:rule abstract="true" id="IVL_INT.POS-3">
            <sch:assert test="count(*[self::low or self::high or self::width][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.POS">
        <xsd:sequence>
          <xsd:element name="low" type="INT.POS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="INT.POS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="INT.POS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType abstract="true" name="QSET_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="QSET_INT.POS-0">
            <sch:assert test="count(*[self::originalText][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_CO-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_CO-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_CO">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="CO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="CO" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="CO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_TS-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_TS-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="TS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATE-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATE-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATE">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATE" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.DATE" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="TS.DATE" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATE.FULL-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATE.FULL-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.DATE.FULL" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATETIME-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATETIME-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATETIME">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATETIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.DATETIME" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="TS.DATETIME" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATETIME.FULL-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_TS.DATETIME.FULL-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_TS.BIRTH-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_TS.BIRTH-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.BIRTH">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.BIRTH" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.BIRTH" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="TS.BIRTH" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_RTO-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_RTO-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_RTO">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="RTO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="RTO" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="RTO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_MO-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_MO-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_MO">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="MO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="MO" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="MO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_PQ-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_PQ-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_PQ">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="PQ" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="PQ" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="PQ" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_PQ.TIME-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_PQ.TIME-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_PQ.TIME">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="PQ.TIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="PQ.TIME" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="PQ.TIME" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_REAL-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_REAL-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_REAL">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="REAL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="REAL" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="REAL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_INT-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_INT-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="INT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="INT" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="INT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_INT.NONNEG-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_INT.NONNEG-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT.NONNEG">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="INT.NONNEG" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="INT.NONNEG" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="INT.NONNEG" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.LOW_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.LOW_INT.POS-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.LOW_INT.POS-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT.POS">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="INT.POS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="INT.POS" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="INT.POS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_CO-0">
            <sch:assert test="width and not(width\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_CO-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_CO-2">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_CO">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="CO" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="CO" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="CO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_TS-0">
            <sch:assert test="width and not(width\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_TS-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_TS-2">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="TS" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="TS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATE-0">
            <sch:assert test="width and not(width\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATE-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATE-2">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATE">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATE" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="TS.DATE" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="TS.DATE" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATE.FULL-0">
            <sch:assert test="width and not(width\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATE.FULL-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATE.FULL-2">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATE.FULL" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="TS.DATE.FULL" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATETIME-0">
            <sch:assert test="width and not(width\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATETIME-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATETIME-2">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATETIME">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATETIME" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="TS.DATETIME" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="TS.DATETIME" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATETIME.FULL-0">
            <sch:assert test="width and not(width\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATETIME.FULL-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.DATETIME.FULL-2">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.BIRTH-0">
            <sch:assert test="width and not(width\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.BIRTH-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_TS.BIRTH-2">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.BIRTH">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.BIRTH" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="TS.BIRTH" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="TS.BIRTH" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_RTO-0">
            <sch:assert test="width and not(width\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_RTO-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_RTO-2">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_RTO">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="RTO" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="RTO" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="RTO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_MO-0">
            <sch:assert test="width and not(width\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_MO-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_MO-2">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_MO">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="MO" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="MO" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="MO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_PQ-0">
            <sch:assert test="width and not(width\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_PQ-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_PQ-2">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_PQ">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="PQ" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="PQ" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="PQ" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_PQ.TIME-0">
            <sch:assert test="width and not(width\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_PQ.TIME-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_PQ.TIME-2">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_PQ.TIME">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="PQ.TIME" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="PQ.TIME" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="PQ.TIME" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_REAL-0">
            <sch:assert test="width and not(width\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_REAL-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_REAL-2">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_REAL">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="REAL" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="REAL" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="REAL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_INT-0">
            <sch:assert test="width and not(width\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_INT-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_INT-2">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="INT" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="INT" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="INT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_INT.NONNEG-0">
            <sch:assert test="width and not(width\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_INT.NONNEG-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_INT.NONNEG-2">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT.NONNEG">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="INT.NONNEG" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="INT.NONNEG" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="INT.NONNEG" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.WIDTH_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="width">
          <sch:rule abstract="true" id="IVL.WIDTH_INT.POS-0">
            <sch:assert test="width and not(width\@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.WIDTH_INT.POS-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.WIDTH_INT.POS-2">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT.POS">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="INT.POS" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="INT.POS" minOccurs="0" maxOccurs="0" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="any" type="INT.POS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_CO-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_CO-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_CO">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="CO" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="CO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="CO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_TS-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_TS-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="TS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="TS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATE-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATE-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATE">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATE" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="TS.DATE" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="TS.DATE" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATE.FULL-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATE.FULL-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATE.FULL" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATETIME-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATETIME-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATETIME">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATETIME" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="TS.DATETIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="TS.DATETIME" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATETIME.FULL-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_TS.DATETIME.FULL-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_TS.BIRTH-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_TS.BIRTH-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_TS.BIRTH">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.BIRTH" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="TS.BIRTH" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="TS.BIRTH" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_RTO-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_RTO-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_RTO">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="RTO" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="RTO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="RTO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_MO-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_MO-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_MO">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="MO" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="MO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="MO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_PQ-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_PQ-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_PQ">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="PQ" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="PQ" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="PQ" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_PQ.TIME-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_PQ.TIME-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_PQ.TIME">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="PQ.TIME" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="PQ.TIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="PQ.TIME" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_REAL-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_REAL-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_REAL">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="REAL" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="REAL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="REAL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_INT-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_INT-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="INT" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="INT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="INT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_INT.NONNEG-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_INT.NONNEG-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT.NONNEG">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="INT.NONNEG" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="INT.NONNEG" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="INT.NONNEG" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="IVL.HIGH_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="IVL.HIGH_INT.POS-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="IVL.HIGH_INT.POS-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="IVL_INT.POS">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="INT.POS" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="INT.POS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="width" type="QTY" minOccurs="0" maxOccurs="0" />
          <xsd:element name="any" type="INT.POS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_CO-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_CO-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="CO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="TS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATE-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATE-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="TS.DATE" minOccurs="0" maxOccurs="1" />
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATE.FULL-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATETIME-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="TS.DATETIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS.DATETIME.FULL-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_TS.BIRTH-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="TS.BIRTH" minOccurs="0" maxOccurs="1" />
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_RTO-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_RTO-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="RTO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_MO-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_MO-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="MO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_PQ-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_PQ-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="PQ" minOccurs="0" maxOccurs="1" />
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_PQ.TIME-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_PQ.TIME-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="PQ.TIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_REAL-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_REAL-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="REAL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_INT-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_INT-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="INT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_INT.NONNEG-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="INT.NONNEG" minOccurs="0" maxOccurs="1" />
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="SLIST_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="SLIST_INT.POS-0">
            <sch:assert test="@nullFlavor or (origin and not(origin\@nullFlavor) and count(*[digits\not(@nullFlavor))&#62;0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on SLIST attributes">
          <sch:rule abstract="true" id="SLIST_INT.POS-1">
            <sch:assert test="count(*[self::origin or self::scale or self::digits][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="origin" type="INT.POS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="scale" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="digit" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_CO-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_CO-1">
            <sch:assert test="not(@denominator) or (@denominator &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_CO-2">
            <sch:assert test="todo" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_CO-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="head" type="CO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="increment" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional" />
        <xsd:attribute name="period" type="xsd:int" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS-1">
            <sch:assert test="not(@denominator) or (@denominator &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS-2">
            <sch:assert test="todo" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_TS-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="head" type="TS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="increment" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional" />
        <xsd:attribute name="period" type="xsd:int" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATE-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATE-1">
            <sch:assert test="not(@denominator) or (@denominator &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATE-2">
            <sch:assert test="todo" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATE-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="head" type="TS.DATE" minOccurs="0" maxOccurs="1" />
          <xsd:element name="increment" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional" />
        <xsd:attribute name="period" type="xsd:int" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATE.FULL-1">
            <sch:assert test="not(@denominator) or (@denominator &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATE.FULL-2">
            <sch:assert test="todo" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATE.FULL-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="head" type="TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="increment" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional" />
        <xsd:attribute name="period" type="xsd:int" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME-1">
            <sch:assert test="not(@denominator) or (@denominator &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME-2">
            <sch:assert test="todo" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="head" type="TS.DATETIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="increment" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional" />
        <xsd:attribute name="period" type="xsd:int" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME.FULL-1">
            <sch:assert test="not(@denominator) or (@denominator &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME.FULL-2">
            <sch:assert test="todo" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_TS.DATETIME.FULL-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="head" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="increment" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional" />
        <xsd:attribute name="period" type="xsd:int" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_TS.BIRTH-1">
            <sch:assert test="not(@denominator) or (@denominator &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_TS.BIRTH-2">
            <sch:assert test="todo" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_TS.BIRTH-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="head" type="TS.BIRTH" minOccurs="0" maxOccurs="1" />
          <xsd:element name="increment" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional" />
        <xsd:attribute name="period" type="xsd:int" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_RTO-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_RTO-1">
            <sch:assert test="not(@denominator) or (@denominator &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_RTO-2">
            <sch:assert test="todo" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_RTO-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="head" type="RTO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="increment" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional" />
        <xsd:attribute name="period" type="xsd:int" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_MO-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_MO-1">
            <sch:assert test="not(@denominator) or (@denominator &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_MO-2">
            <sch:assert test="todo" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_MO-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="head" type="MO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="increment" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional" />
        <xsd:attribute name="period" type="xsd:int" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_PQ-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_PQ-1">
            <sch:assert test="not(@denominator) or (@denominator &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_PQ-2">
            <sch:assert test="todo" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_PQ-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="head" type="PQ" minOccurs="0" maxOccurs="1" />
          <xsd:element name="increment" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional" />
        <xsd:attribute name="period" type="xsd:int" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_PQ.TIME-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_PQ.TIME-1">
            <sch:assert test="not(@denominator) or (@denominator &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_PQ.TIME-2">
            <sch:assert test="todo" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_PQ.TIME-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="head" type="PQ.TIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="increment" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional" />
        <xsd:attribute name="period" type="xsd:int" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_REAL-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_REAL-1">
            <sch:assert test="not(@denominator) or (@denominator &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_REAL-2">
            <sch:assert test="todo" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_REAL-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="head" type="REAL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="increment" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional" />
        <xsd:attribute name="period" type="xsd:int" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_INT-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_INT-1">
            <sch:assert test="not(@denominator) or (@denominator &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_INT-2">
            <sch:assert test="todo" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_INT-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="head" type="INT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="increment" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional" />
        <xsd:attribute name="period" type="xsd:int" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_INT.NONNEG-1">
            <sch:assert test="not(@denominator) or (@denominator &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_INT.NONNEG-2">
            <sch:assert test="todo" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_INT.NONNEG-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="head" type="INT.NONNEG" minOccurs="0" maxOccurs="1" />
          <xsd:element name="increment" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional" />
        <xsd:attribute name="period" type="xsd:int" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="GLIST_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="GLIST_INT.POS-0">
            <sch:assert test="@nullFlavor or (head and not(head\@nullFlavor) and increment and not(increment\@nullFlavor) and @denominator)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="denominator must be positive">
          <sch:rule abstract="true" id="GLIST_INT.POS-1">
            <sch:assert test="not(@denominator) or (@denominator &#62; 0)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="period must be positive">
          <sch:rule abstract="true" id="GLIST_INT.POS-2">
            <sch:assert test="todo" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on GLIST attributes">
          <sch:rule abstract="true" id="GLIST_INT.POS-3">
            <sch:assert test="count(*[self::head or self::increment][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="head" type="INT.POS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="increment" type="QTY" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="denominator" type="xsd:int" use="optional" />
        <xsd:attribute name="period" type="xsd:int" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_CO-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_CO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_CO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_TS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_TS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS.DATE-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_TS.DATE" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_TS.DATE" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_TS.DATETIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_TS.DATETIME" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_TS.BIRTH" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_TS.BIRTH" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_RTO-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_RTO">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_RTO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_RTO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_MO-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_MO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_MO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_PQ-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_PQ" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_PQ" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_PQ.TIME-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ.TIME">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_PQ.TIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_PQ.TIME" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_REAL-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_REAL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_REAL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_INT-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_INT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_INT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.NONNEG">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_INT.NONNEG" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_INT.NONNEG" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSD_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSD_INT.POS-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.POS">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_INT.POS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_INT.POS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_CO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_CO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_CO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_TS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS.DATE-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS.DATE-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_TS.DATE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS.DATE.FULL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_TS.DATE.FULL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS.DATETIME-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_TS.DATETIME" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS.DATETIME.FULL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_TS.DATETIME.FULL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_TS.BIRTH-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_TS.BIRTH" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_RTO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_RTO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_RTO">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_RTO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_MO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_MO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_MO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_PQ-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_PQ-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_PQ" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_PQ.TIME-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_PQ.TIME-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ.TIME">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_PQ.TIME" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_REAL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_REAL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_REAL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_INT-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_INT-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_INT.NONNEG-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.NONNEG">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_INT.NONNEG" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSI_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSI_INT.POS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSI_INT.POS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.POS">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_INT.POS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_CO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_CO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_CO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_TS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS.DATE-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS.DATE-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_TS.DATE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS.DATE.FULL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_TS.DATE.FULL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS.DATETIME-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_TS.DATETIME" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS.DATETIME.FULL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_TS.DATETIME.FULL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_TS.BIRTH-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_TS.BIRTH" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_RTO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_RTO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_RTO">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_RTO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_MO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_MO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_MO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_PQ-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_PQ-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_PQ" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_PQ.TIME-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_PQ.TIME-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ.TIME">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_PQ.TIME" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_REAL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_REAL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_REAL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_INT-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_INT-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_INT.NONNEG-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.NONNEG">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_INT.NONNEG" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSU_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSU_INT.POS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSU_INT.POS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 2)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.POS">
        <xsd:sequence>
          <xsd:element name="term" type="QSET_INT.POS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_CO-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_CO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_CO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_TS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_TS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS.DATE-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_TS.DATE" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_TS.DATE" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_TS.DATETIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_TS.DATETIME" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_TS.BIRTH" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_TS.BIRTH" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_RTO-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_RTO">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_RTO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_RTO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_MO-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_MO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_MO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_PQ-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_PQ" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_PQ" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_PQ.TIME-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ.TIME">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_PQ.TIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_PQ.TIME" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_REAL-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_REAL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_REAL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_INT-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_INT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_INT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.NONNEG">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_INT.NONNEG" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_INT.NONNEG" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSP_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSP_INT.POS-0">
            <sch:assert test="@nullFlavor or (not(first/@nullFlavor) and not(second/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.POS">
        <xsd:sequence>
          <xsd:element name="first" type="QSET_INT.POS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="second" type="QSET_INT.POS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_CO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_CO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_CO-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_CO-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_CO">
        <xsd:sequence>
          <xsd:element name="term" type="CO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element name="term" type="TS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATE-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATE-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATE-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATE-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element name="term" type="TS.DATE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATE.FULL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATE.FULL-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATE.FULL-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element name="term" type="TS.DATE.FULL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATETIME-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATETIME-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATETIME-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element name="term" type="TS.DATETIME" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATETIME.FULL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.DATETIME.FULL-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.DATETIME.FULL-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element name="term" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.BIRTH-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_TS.BIRTH-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_TS.BIRTH-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element name="term" type="TS.BIRTH" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_RTO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_RTO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_RTO-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_RTO-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_RTO">
        <xsd:sequence>
          <xsd:element name="term" type="RTO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_MO-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_MO-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_MO-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_MO-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_MO">
        <xsd:sequence>
          <xsd:element name="term" type="MO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_PQ-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_PQ-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_PQ-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_PQ-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ">
        <xsd:sequence>
          <xsd:element name="term" type="PQ" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_PQ.TIME-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_PQ.TIME-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_PQ.TIME-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_PQ.TIME-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_PQ.TIME">
        <xsd:sequence>
          <xsd:element name="term" type="PQ.TIME" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_REAL-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_REAL-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_REAL-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_REAL-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_REAL">
        <xsd:sequence>
          <xsd:element name="term" type="REAL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_INT-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_INT-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_INT-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_INT-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT">
        <xsd:sequence>
          <xsd:element name="term" type="INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_INT.NONNEG-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_INT.NONNEG-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_INT.NONNEG-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.NONNEG">
        <xsd:sequence>
          <xsd:element name="term" type="INT.NONNEG" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSS_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_INT.POS-0">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_INT.POS-1">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="not null">
          <sch:rule abstract="true" id="QSS_INT.POS-2">
            <sch:assert test="@nullFlavor or not(terms/@nullFlavor)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="size">
          <sch:rule abstract="true" id="QSS_INT.POS-3">
            <sch:assert test="@nullFlavor or (count(*[self::terms]) &#62;= 1)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_INT.POS">
        <xsd:sequence>
          <xsd:element name="term" type="INT.POS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS-0">
            <sch:assert test="not(period) or not(frequency)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element name="phase" type="IVL_TS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="period" type="PQ" minOccurs="0" maxOccurs="1" />
          <xsd:element name="frequency" type="RTO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="count" type="INT.POS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional" />
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS.DATE-0">
            <sch:assert test="not(period) or not(frequency)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS.DATE-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element name="phase" type="IVL_TS.DATE" minOccurs="0" maxOccurs="1" />
          <xsd:element name="period" type="PQ" minOccurs="0" maxOccurs="1" />
          <xsd:element name="frequency" type="RTO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="count" type="INT.POS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional" />
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS.DATE.FULL-0">
            <sch:assert test="not(period) or not(frequency)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS.DATE.FULL-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element name="phase" type="IVL_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="period" type="PQ" minOccurs="0" maxOccurs="1" />
          <xsd:element name="frequency" type="RTO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="count" type="INT.POS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional" />
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS.DATETIME-0">
            <sch:assert test="not(period) or not(frequency)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS.DATETIME-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element name="phase" type="IVL_TS.DATETIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="period" type="PQ" minOccurs="0" maxOccurs="1" />
          <xsd:element name="frequency" type="RTO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="count" type="INT.POS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional" />
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS.DATETIME.FULL-0">
            <sch:assert test="not(period) or not(frequency)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS.DATETIME.FULL-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element name="phase" type="IVL_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="period" type="PQ" minOccurs="0" maxOccurs="1" />
          <xsd:element name="frequency" type="RTO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="count" type="INT.POS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional" />
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="PIVL_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="period or frequency">
          <sch:rule abstract="true" id="PIVL_TS.BIRTH-0">
            <sch:assert test="not(period) or not(frequency)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on PIVL attributes">
          <sch:rule abstract="true" id="PIVL_TS.BIRTH-1">
            <sch:assert test="count(*[self::phase or self::period][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element name="phase" type="IVL_TS.BIRTH" minOccurs="0" maxOccurs="1" />
          <xsd:element name="period" type="PQ" minOccurs="0" maxOccurs="1" />
          <xsd:element name="frequency" type="RTO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="count" type="INT.POS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="alignment" type="CalendarCycle" use="optional" />
        <xsd:attribute name="isFlexible" type="xsd:boolean" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS-0">
            <sch:assert test="@nullFlavor or (event)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS">
        <xsd:sequence>
          <xsd:element name="offset" type="IVL_PQ" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATE-0">
            <sch:assert test="@nullFlavor or (event)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATE-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE">
        <xsd:sequence>
          <xsd:element name="offset" type="IVL_PQ" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or (event)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATE.FULL-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element name="offset" type="IVL_PQ" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or (event)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATETIME-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME">
        <xsd:sequence>
          <xsd:element name="offset" type="IVL_PQ" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or (event)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS.DATETIME.FULL-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element name="offset" type="IVL_PQ" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="EIVL_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="required attributes">
          <sch:rule abstract="true" id="EIVL_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or (event)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="no updateMode or History on EIVL attributes">
          <sch:rule abstract="true" id="EIVL_TS.BIRTH-1">
            <sch:assert test="count(*[self::offset][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QSET_TS.BIRTH">
        <xsd:sequence>
          <xsd:element name="offset" type="IVL_PQ" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="event" type="TimingEvent" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_BL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_BL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_BL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_BL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_BL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_BL-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_BL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="BL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_BL.NONNULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_BL.NONNULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_BL.NONNULL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_BL.NONNULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_BL.NONNULL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_BL.NONNULL-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_BL.NONNULL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="BL.NONNULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_ED" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="ED" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.IMAGE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.IMAGE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_ED.IMAGE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.IMAGE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.IMAGE-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.IMAGE-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.IMAGE-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="ED.IMAGE" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.TEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.TEXT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_ED.TEXT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.TEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.TEXT-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.TEXT-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.TEXT-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.DOC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.DOC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_ED.DOC" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.DOC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.DOC-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.DOC-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.DOC-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="ED.DOC" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.DOC.REF">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.DOC.REF-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_ED.DOC.REF" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.DOC.REF">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.DOC.REF-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.DOC.REF-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.DOC.REF-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="ED.DOC.REF" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.DOC.INLINE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.DOC.INLINE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_ED.DOC.INLINE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.DOC.INLINE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.DOC.INLINE-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.DOC.INLINE-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.DOC.INLINE-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="ED.DOC.INLINE" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.SIGNATURE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.SIGNATURE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_ED.SIGNATURE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.SIGNATURE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.SIGNATURE-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.SIGNATURE-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.SIGNATURE-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="ED.SIGNATURE" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ED.STRUCTUREDTEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ED.STRUCTUREDTEXT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_ED.STRUCTUREDTEXT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ED.STRUCTUREDTEXT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ED.STRUCTUREDTEXT-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ED.STRUCTUREDTEXT-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ED.STRUCTUREDTEXT-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="ED.STRUCTUREDTEXT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ST">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ST-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_ST" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ST">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ST-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ST-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ST-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="ST" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_ST.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_ST.NT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_ST.NT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_ST.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_ST.NT-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_ST.NT-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_ST.NT-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="ST.NT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_SC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_SC-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_SC" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_SC">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_SC-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_SC-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_SC-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="SC" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_SC.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_SC.NT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_SC.NT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_SC.NT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_SC.NT-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_SC.NT-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_SC.NT-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="SC.NT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TEL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TEL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_TEL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TEL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TEL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TEL-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TEL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="TEL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TEL.EMAIL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TEL.EMAIL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_TEL.EMAIL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TEL.EMAIL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TEL.EMAIL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TEL.EMAIL-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TEL.EMAIL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="TEL.EMAIL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TEL.PERSON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TEL.PERSON-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_TEL.PERSON" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TEL.PERSON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TEL.PERSON-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TEL.PERSON-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TEL.PERSON-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="TEL.PERSON" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TEL.PHONE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TEL.PHONE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_TEL.PHONE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TEL.PHONE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TEL.PHONE-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TEL.PHONE-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TEL.PHONE-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="TEL.PHONE" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TEL.URL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TEL.URL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_TEL.URL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TEL.URL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TEL.URL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TEL.URL-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TEL.URL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="TEL.URL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_II">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_II-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_II" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_II">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_II-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_II-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_II-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="II" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_CD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_CD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_CD" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_CD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_CD-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_CD-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_CD-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="CD" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_CD.CV">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_CD.CV-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_CD.CV" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_CD.CV">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_CD.CV-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_CD.CV-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_CD.CV-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="CD.CV" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_CO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_CO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_CO-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_CO-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_CO-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="CO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_CS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_CS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_CS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_CS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_CS-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_CS-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_CS-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="CS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_AD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_AD-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_AD" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_AD">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_AD-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_AD-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_AD-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="AD" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_EN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_EN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_EN" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_EN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_EN-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_EN-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_EN-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="EN" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_EN.TN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_EN.TN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_EN.TN" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_EN.TN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_EN.TN-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_EN.TN-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_EN.TN-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="EN.TN" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_EN.PN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_EN.PN-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_EN.PN" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_EN.PN">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_EN.PN-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_EN.PN-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_EN.PN-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="EN.PN" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_EN.ON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_EN.ON-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_EN.ON" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_EN.ON">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_EN.ON-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_EN.ON-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_EN.ON-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="EN.ON" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_TS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TS-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="TS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS.DATE-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_TS.DATE" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TS.DATE-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS.DATE-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS.DATE-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="TS.DATE" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS.DATE.FULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_TS.DATE.FULL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TS.DATE.FULL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS.DATE.FULL-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS.DATE.FULL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS.DATETIME-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_TS.DATETIME" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TS.DATETIME-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS.DATETIME-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS.DATETIME-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="TS.DATETIME" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS.DATETIME.FULL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_TS.DATETIME.FULL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TS.DATETIME.FULL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS.DATETIME.FULL-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS.DATETIME.FULL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_TS.BIRTH-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_TS.BIRTH" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_TS.BIRTH-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_TS.BIRTH-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_TS.BIRTH-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="TS.BIRTH" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_RTO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_RTO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_RTO-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_RTO-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_RTO-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="RTO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_MO-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_MO" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_MO-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_MO-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_MO-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="MO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_PQ-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_PQ" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_PQ-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_PQ-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_PQ-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="PQ" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_PQ.TIME-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_PQ.TIME" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_PQ.TIME-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_PQ.TIME-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_PQ.TIME-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="PQ.TIME" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_REAL-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_REAL" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_REAL-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_REAL-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_REAL-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="REAL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_INT-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_INT" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_INT-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_INT-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_INT-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="INT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_INT.NONNEG-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_INT.NONNEG" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_INT.NONNEG-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_INT.NONNEG-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_INT.NONNEG-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="INT.NONNEG" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="NPPD_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="must have at least one item">
          <sch:rule abstract="true" id="NPPD_INT.POS-0">
            <sch:assert test="(@nullFlavor or item) and not(@nullFlavor and item)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="item" type="UVP_INT.POS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="UVP_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="value not null">
          <sch:rule abstract="true" id="UVP_INT.POS-0">
            <sch:assert test="@nullFlavor or (value and not(value/@nullFlavor))" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="must have probability">
          <sch:rule abstract="true" id="UVP_INT.POS-1">
            <sch:assert test="@nullFlavor or @probability" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="No History or Update Mode">
          <sch:rule abstract="true" id="UVP_INT.POS-2">
            <sch:assert test="count(*[self::value][@validTimeLow or @validTimeHigh or @controlActRoot or @controlActExtension or @updateMode])=0" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="ANY">
        <xsd:sequence>
          <xsd:element name="value" type="INT.POS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="probability" type="xsd:double" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="QSET.BOUNDEDPIVL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="QSET.BOUNDEDPIVL 2">
          <sch:rule abstract="true" id="QSET.BOUNDEDPIVL-0">
            <sch:assert test="count(*)=2" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="QSI_TS">
        <xsd:sequence>
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="term" type="QSET_TS" minOccurs="0" maxOccurs="unbounded" />
        </xsd:sequence>
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_BL">
    <xsd:complexContent>
      <xsd:extension base="LIST_BL" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_BL.NONNULL">
    <xsd:complexContent>
      <xsd:extension base="LIST_BL.NONNULL" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.IMAGE">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.IMAGE" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.TEXT">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.TEXT" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.DOC">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.DOC" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.DOC.REF">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.DOC.REF" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.DOC.INLINE">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.DOC.INLINE" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.SIGNATURE">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.SIGNATURE" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.STRUCTUREDTEXT">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.STRUCTUREDTEXT" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ED.STRUCTUREDTITLE">
    <xsd:complexContent>
      <xsd:extension base="LIST_ED.STRUCTUREDTITLE" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ST">
    <xsd:complexContent>
      <xsd:extension base="LIST_ST" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_ST.NT">
    <xsd:complexContent>
      <xsd:extension base="LIST_ST.NT" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_SC">
    <xsd:complexContent>
      <xsd:extension base="LIST_SC" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_SC.NT">
    <xsd:complexContent>
      <xsd:extension base="LIST_SC.NT" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TEL">
    <xsd:complexContent>
      <xsd:extension base="LIST_TEL" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TEL.EMAIL">
    <xsd:complexContent>
      <xsd:extension base="LIST_TEL.EMAIL" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TEL.PERSON">
    <xsd:complexContent>
      <xsd:extension base="LIST_TEL.PERSON" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TEL.PHONE">
    <xsd:complexContent>
      <xsd:extension base="LIST_TEL.PHONE" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TEL.URL">
    <xsd:complexContent>
      <xsd:extension base="LIST_TEL.URL" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_II">
    <xsd:complexContent>
      <xsd:extension base="LIST_II" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_CD">
    <xsd:complexContent>
      <xsd:extension base="LIST_CD" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_CD.CV">
    <xsd:complexContent>
      <xsd:extension base="LIST_CD.CV" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_CO">
    <xsd:complexContent>
      <xsd:extension base="LIST_CO" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_CS">
    <xsd:complexContent>
      <xsd:extension base="LIST_CS" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_AD">
    <xsd:complexContent>
      <xsd:extension base="LIST_AD" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_EN">
    <xsd:complexContent>
      <xsd:extension base="LIST_EN" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_EN.TN">
    <xsd:complexContent>
      <xsd:extension base="LIST_EN.TN" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_EN.PN">
    <xsd:complexContent>
      <xsd:extension base="LIST_EN.PN" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_EN.ON">
    <xsd:complexContent>
      <xsd:extension base="LIST_EN.ON" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS">
    <xsd:complexContent>
      <xsd:extension base="LIST_TS" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS.DATE">
    <xsd:complexContent>
      <xsd:extension base="LIST_TS.DATE" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS.DATE.FULL">
    <xsd:complexContent>
      <xsd:extension base="LIST_TS.DATE.FULL" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS.DATETIME">
    <xsd:complexContent>
      <xsd:extension base="LIST_TS.DATETIME" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS.DATETIME.FULL">
    <xsd:complexContent>
      <xsd:extension base="LIST_TS.DATETIME.FULL" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_TS.BIRTH">
    <xsd:complexContent>
      <xsd:extension base="LIST_TS.BIRTH" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_RTO">
    <xsd:complexContent>
      <xsd:extension base="LIST_RTO" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_MO">
    <xsd:complexContent>
      <xsd:extension base="LIST_MO" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_PQ">
    <xsd:complexContent>
      <xsd:extension base="LIST_PQ" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_PQ.TIME">
    <xsd:complexContent>
      <xsd:extension base="LIST_PQ.TIME" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_REAL">
    <xsd:complexContent>
      <xsd:extension base="LIST_REAL" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_INT">
    <xsd:complexContent>
      <xsd:extension base="LIST_INT" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_INT.NONNEG">
    <xsd:complexContent>
      <xsd:extension base="LIST_INT.NONNEG" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="HIST_INT.POS">
    <xsd:complexContent>
      <xsd:extension base="LIST_INT.POS" />
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_CO-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="low" type="CO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="CO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_TS-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="low" type="TS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_TS.DATE-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="low" type="TS.DATE" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.DATE" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_TS.DATE.FULL-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="low" type="TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_TS.DATETIME-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="low" type="TS.DATETIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.DATETIME" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_TS.DATETIME.FULL-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="low" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_TS.BIRTH-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="low" type="TS.BIRTH" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.BIRTH" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_RTO-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="low" type="RTO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="RTO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_MO-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="low" type="MO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="MO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_PQ-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="low" type="PQ" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="PQ" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_PQ.TIME-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="low" type="PQ.TIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="PQ.TIME" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_REAL-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="low" type="REAL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="REAL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_INT-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="low" type="INT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="INT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_INT.NONNEG-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="low" type="INT.NONNEG" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="INT.NONNEG" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="no inner attributes">
          <sch:rule abstract="true" id="URG_INT.POS-0">
            <sch:assert test="not(@validTimeLow) and not(@validTimeHigh) and not (@controlActRoot) and not(@controlActExtension) and not(@flavorId) and not(@nullFlavor) and not(@updateMode) and not(expression) and not(originalText) and not(uncertainty) and not(@uncertaintyType)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:extension base="QTY">
        <xsd:sequence>
          <xsd:element name="low" type="INT.POS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="INT.POS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="optional" />
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" use="optional" />
      </xsd:extension>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_CO-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_CO-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_CO">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="CO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="CO" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_TS-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_TS-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_TS.DATE-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_TS.DATE-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATE">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATE" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.DATE" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_TS.DATE.FULL-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_TS.DATE.FULL-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.DATE.FULL" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_TS.DATETIME-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_TS.DATETIME-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATETIME">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATETIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.DATETIME" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_TS.DATETIME.FULL-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_TS.DATETIME.FULL-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_TS.BIRTH-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_TS.BIRTH-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.BIRTH">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.BIRTH" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="TS.BIRTH" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_RTO-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_RTO-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_RTO">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="RTO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="RTO" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_MO-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_MO-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_MO">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="MO" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="MO" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_PQ-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_PQ-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_PQ">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="PQ" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="PQ" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_PQ.TIME-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_PQ.TIME-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_PQ.TIME">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="PQ.TIME" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="PQ.TIME" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_REAL-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_REAL-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_REAL">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="REAL" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="REAL" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_INT-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_INT-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_INT">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="INT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="INT" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_INT.NONNEG-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_INT.NONNEG-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_INT.NONNEG">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="INT.NONNEG" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="INT.NONNEG" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.LOW_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.LOW_INT.POS-0">
            <sch:assert test="low and not(low\@nullFlavor) and (@lowClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.LOW_INT.POS-1">
            <sch:assert test="not(high) and not(@highClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_INT.POS">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="INT.POS" minOccurs="0" maxOccurs="1" />
          <xsd:element name="high" type="INT.POS" minOccurs="0" maxOccurs="0" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="highClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_CO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_CO-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_CO-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_CO">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="CO" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="CO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_TS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_TS-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_TS-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="TS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_TS.DATE">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATE-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATE-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATE">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATE" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="TS.DATE" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_TS.DATE.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATE.FULL-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATE.FULL-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATE.FULL">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATE.FULL" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_TS.DATETIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATETIME-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATETIME-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATETIME">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATETIME" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="TS.DATETIME" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_TS.DATETIME.FULL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATETIME.FULL-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_TS.DATETIME.FULL-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.DATETIME.FULL">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_TS.BIRTH">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_TS.BIRTH-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_TS.BIRTH-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_TS.BIRTH">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="TS.BIRTH" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="TS.BIRTH" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_RTO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_RTO-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_RTO-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_RTO">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="RTO" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="RTO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_MO">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_MO-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_MO-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_MO">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="MO" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="MO" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_PQ">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_PQ-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_PQ-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_PQ">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="PQ" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="PQ" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_PQ.TIME">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_PQ.TIME-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_PQ.TIME-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_PQ.TIME">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="PQ.TIME" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="PQ.TIME" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_REAL">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_REAL-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_REAL-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_REAL">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="REAL" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="REAL" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_INT">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_INT-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_INT-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_INT">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="INT" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="INT" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_INT.NONNEG">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_INT.NONNEG-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_INT.NONNEG-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_INT.NONNEG">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="INT.NONNEG" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="INT.NONNEG" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:complexType name="URG.HIGH_INT.POS">
    <xsd:annotation>
      <xsd:appinfo>
        <sch:pattern name="high">
          <sch:rule abstract="true" id="URG.HIGH_INT.POS-0">
            <sch:assert test="high and not(high\@nullFlavor) and (@highClosed = &#34;true&#34;)" />
          </sch:rule>
        </sch:pattern>
        <sch:pattern name="low">
          <sch:rule abstract="true" id="URG.HIGH_INT.POS-1">
            <sch:assert test="not(low) and not(@lowClosed)" />
          </sch:rule>
        </sch:pattern>
      </xsd:appinfo>
    </xsd:annotation>
    <xsd:complexContent>
      <xsd:restriction base="URG_INT.POS">
        <xsd:sequence>
          <xsd:element name="expression" type="ED" minOccurs="0" maxOccurs="1" />
          <xsd:element name="originalText" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
          <xsd:element name="uncertainty" type="QTY" minOccurs="0" maxOccurs="1" />
          <xsd:element name="low" type="INT.POS" minOccurs="0" maxOccurs="0" />
          <xsd:element name="high" type="INT.POS" minOccurs="0" maxOccurs="1" />
        </xsd:sequence>
        <xsd:attribute name="nullFlavor" type="NullFlavor" fixed="UNK" />
        <xsd:attribute name="lowClosed" type="xsd:boolean" use="prohibited" />
      </xsd:restriction>
    </xsd:complexContent>
  </xsd:complexType>
  <xsd:element name="Factory" type="Factory" />
  <xsd:complexType name="Factory">
    <xsd:sequence>
      <xsd:element name="st" type="StrucDoc.Text" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aBL" type="BL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aBL1" type="BL.NONNULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aED" type="ED" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aED1" type="ED.IMAGE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aED2" type="ED.TEXT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aED3" type="ED.DOC" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aED4" type="ED.DOC.REF" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aED5" type="ED.DOC.INLINE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aED6" type="ED.SIGNATURE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aED7" type="ED.STRUCTUREDTEXT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aED8" type="ED.STRUCTUREDTITLE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aST" type="ST" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aST1" type="ST.NT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aSC" type="SC" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aSC1" type="SC.NT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aTEL" type="TEL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aTEL1" type="TEL.EMAIL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aTEL2" type="TEL.PERSON" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aTEL3" type="TEL.PHONE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aTEL4" type="TEL.URL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aII" type="II" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aCD" type="CD" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aCV" type="CD.CV" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aCO" type="CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aCS" type="CS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aAD" type="AD" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aEN" type="EN" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aTN" type="EN.TN" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aPN" type="EN.PN" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aON" type="EN.ON" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aTS" type="TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aTS1" type="TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aTS2" type="TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aTS3" type="TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aTS4" type="TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aTS5" type="TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aRTO" type="RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aMO" type="MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aPQ" type="PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aPQ1" type="PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aREAL" type="REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aINT" type="INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aINT1" type="INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aINT2" type="INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sBL" type="DSET_BL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sBL1" type="DSET_BL.NONNULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sED" type="DSET_ED" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sED1" type="DSET_ED.IMAGE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sED2" type="DSET_ED.TEXT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sED3" type="DSET_ED.DOC" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sED4" type="DSET_ED.DOC.REF" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sED5" type="DSET_ED.DOC.INLINE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sED6" type="DSET_ED.SIGNATURE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sED7" type="DSET_ED.STRUCTUREDTEXT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sED8" type="DSET_ED.STRUCTUREDTITLE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sST" type="DSET_ST" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sST1" type="DSET_ST.NT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sSC" type="DSET_SC" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sSC1" type="DSET_SC.NT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sTEL" type="DSET_TEL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sTEL1" type="DSET_TEL.EMAIL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sTEL2" type="DSET_TEL.PERSON" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sTEL3" type="DSET_TEL.PHONE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sTEL4" type="DSET_TEL.URL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sII" type="DSET_II" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sCD" type="DSET_CD" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sCV" type="DSET_CD.CV" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sCO" type="DSET_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sCS" type="DSET_CS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sAD" type="DSET_AD" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sEN" type="DSET_EN" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sTN" type="DSET_EN.TN" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sPN" type="DSET_EN.PN" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sON" type="DSET_EN.ON" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sTS" type="DSET_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sTS1" type="DSET_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sTS2" type="DSET_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sTS3" type="DSET_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sTS4" type="DSET_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sTS5" type="DSET_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sRTO" type="DSET_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sMO" type="DSET_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sPQ" type="DSET_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sPQ1" type="DSET_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sREAL" type="DSET_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sINT" type="DSET_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sINT1" type="DSET_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="sINT2" type="DSET_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bBL" type="BAG_BL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bBL1" type="BAG_BL.NONNULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bED" type="BAG_ED" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bED1" type="BAG_ED.IMAGE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bED2" type="BAG_ED.TEXT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bED3" type="BAG_ED.DOC" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bED4" type="BAG_ED.DOC.REF" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bED5" type="BAG_ED.DOC.INLINE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bED6" type="BAG_ED.SIGNATURE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bED7" type="BAG_ED.STRUCTUREDTEXT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bED8" type="BAG_ED.STRUCTUREDTITLE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bST" type="BAG_ST" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bST1" type="BAG_ST.NT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bSC" type="BAG_SC" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bSC1" type="BAG_SC.NT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bTEL" type="BAG_TEL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bTEL1" type="BAG_TEL.EMAIL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bTEL2" type="BAG_TEL.PERSON" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bTEL3" type="BAG_TEL.PHONE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bTEL4" type="BAG_TEL.URL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bII" type="BAG_II" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bCD" type="BAG_CD" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bCV" type="BAG_CD.CV" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bCO" type="BAG_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bCS" type="BAG_CS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bAD" type="BAG_AD" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bEN" type="BAG_EN" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bTN" type="BAG_EN.TN" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bPN" type="BAG_EN.PN" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bON" type="BAG_EN.ON" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bTS" type="BAG_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bTS1" type="BAG_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bTS2" type="BAG_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bTS3" type="BAG_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bTS4" type="BAG_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bTS5" type="BAG_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bRTO" type="BAG_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bMO" type="BAG_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bPQ" type="BAG_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bPQ1" type="BAG_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bREAL" type="BAG_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bINT" type="BAG_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bINT1" type="BAG_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="bINT2" type="BAG_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lBL" type="LIST_BL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lBL1" type="LIST_BL.NONNULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lED" type="LIST_ED" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lED1" type="LIST_ED.IMAGE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lED2" type="LIST_ED.TEXT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lED3" type="LIST_ED.DOC" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lED4" type="LIST_ED.DOC.REF" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lED5" type="LIST_ED.DOC.INLINE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lED6" type="LIST_ED.SIGNATURE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lED7" type="LIST_ED.STRUCTUREDTEXT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lED8" type="LIST_ED.STRUCTUREDTITLE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lST" type="LIST_ST" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lST1" type="LIST_ST.NT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lSC" type="LIST_SC" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lSC1" type="LIST_SC.NT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lTEL" type="LIST_TEL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lTEL1" type="LIST_TEL.EMAIL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lTEL2" type="LIST_TEL.PERSON" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lTEL3" type="LIST_TEL.PHONE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lTEL4" type="LIST_TEL.URL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lII" type="LIST_II" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lCD" type="LIST_CD" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lCV" type="LIST_CD.CV" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lCO" type="LIST_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lCS" type="LIST_CS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lAD" type="LIST_AD" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lEN" type="LIST_EN" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lTN" type="LIST_EN.TN" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lPN" type="LIST_EN.PN" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lON" type="LIST_EN.ON" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lTS" type="LIST_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lTS1" type="LIST_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lTS2" type="LIST_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lTS3" type="LIST_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lTS4" type="LIST_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lTS5" type="LIST_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lRTO" type="LIST_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lMO" type="LIST_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lPQ" type="LIST_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lPQ1" type="LIST_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lREAL" type="LIST_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lINT" type="LIST_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lINT1" type="LIST_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="lINT2" type="LIST_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilCO" type="IVL_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilTS" type="IVL_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilTS1" type="IVL_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilTS2" type="IVL_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilTS3" type="IVL_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilTS4" type="IVL_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilTS5" type="IVL_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilRTO" type="IVL_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilMO" type="IVL_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilPQ" type="IVL_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilPQ1" type="IVL_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilREAL" type="IVL_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilINT" type="IVL_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilINT1" type="IVL_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilINT2" type="IVL_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="illCO" type="IVL.LOW_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="illTS" type="IVL.LOW_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="illTS1" type="IVL.LOW_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="illTS2" type="IVL.LOW_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="illTS3" type="IVL.LOW_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="illTS4" type="IVL.LOW_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="illTS5" type="IVL.LOW_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="illRTO" type="IVL.LOW_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="illMO" type="IVL.LOW_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="illPQ" type="IVL.LOW_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="illPQ1" type="IVL.LOW_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="illREAL" type="IVL.LOW_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="illINT" type="IVL.LOW_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="illINT1" type="IVL.LOW_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="illINT2" type="IVL.LOW_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilwCO" type="IVL.WIDTH_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilwTS" type="IVL.WIDTH_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilwTS1" type="IVL.WIDTH_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilwTS2" type="IVL.WIDTH_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilwTS3" type="IVL.WIDTH_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilwTS4" type="IVL.WIDTH_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilwTS5" type="IVL.WIDTH_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilwRTO" type="IVL.WIDTH_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilwMO" type="IVL.WIDTH_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilwPQ" type="IVL.WIDTH_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilwPQ1" type="IVL.WIDTH_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilwREAL" type="IVL.WIDTH_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilwINT" type="IVL.WIDTH_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilwINT1" type="IVL.WIDTH_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilwINT2" type="IVL.WIDTH_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilhCO" type="IVL.HIGH_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilhTS" type="IVL.HIGH_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilhTS1" type="IVL.HIGH_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilhTS2" type="IVL.HIGH_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilhTS3" type="IVL.HIGH_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilhTS4" type="IVL.HIGH_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilhTS5" type="IVL.HIGH_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilhRTO" type="IVL.HIGH_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilhMO" type="IVL.HIGH_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilhPQ" type="IVL.HIGH_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilhPQ1" type="IVL.HIGH_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilhREAL" type="IVL.HIGH_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilhINT" type="IVL.HIGH_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilhINT1" type="IVL.HIGH_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ilhINT2" type="IVL.HIGH_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="slCO" type="SLIST_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="slTS" type="SLIST_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="slTS1" type="SLIST_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="slTS2" type="SLIST_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="slTS3" type="SLIST_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="slTS4" type="SLIST_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="slTS5" type="SLIST_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="slRTO" type="SLIST_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="slMO" type="SLIST_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="slPQ" type="SLIST_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="slPQ1" type="SLIST_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="slREAL" type="SLIST_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="slINT" type="SLIST_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="slINT1" type="SLIST_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="slINT2" type="SLIST_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="glCO" type="GLIST_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="glTS" type="GLIST_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="glTS1" type="GLIST_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="glTS2" type="GLIST_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="glTS3" type="GLIST_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="glTS4" type="GLIST_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="glTS5" type="GLIST_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="glRTO" type="GLIST_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="glMO" type="GLIST_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="glPQ" type="GLIST_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="glPQ1" type="GLIST_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="glREAL" type="GLIST_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="glINT" type="GLIST_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="glINT1" type="GLIST_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="glINT2" type="GLIST_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsdCO" type="QSD_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsdTS" type="QSD_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsdTS1" type="QSD_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsdTS2" type="QSD_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsdTS3" type="QSD_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsdTS4" type="QSD_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsdTS5" type="QSD_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsdRTO" type="QSD_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsdMO" type="QSD_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsdPQ" type="QSD_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsdPQ1" type="QSD_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsdREAL" type="QSD_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsdINT" type="QSD_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsdINT1" type="QSD_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsdINT2" type="QSD_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsiCO" type="QSI_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsiTS" type="QSI_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsiTS1" type="QSI_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsiTS2" type="QSI_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsiTS3" type="QSI_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsiTS4" type="QSI_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsiTS5" type="QSI_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsiRTO" type="QSI_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsiMO" type="QSI_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsiPQ" type="QSI_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsiPQ1" type="QSI_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsiREAL" type="QSI_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsiINT" type="QSI_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsiINT1" type="QSI_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsiINT2" type="QSI_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsuCO" type="QSU_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsuTS" type="QSU_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsuTS1" type="QSU_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsuTS2" type="QSU_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsuTS3" type="QSU_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsuTS4" type="QSU_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsuTS5" type="QSU_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsuRTO" type="QSU_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsuMO" type="QSU_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsuPQ" type="QSU_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsuPQ1" type="QSU_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsuREAL" type="QSU_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsuINT" type="QSU_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsuINT1" type="QSU_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsuINT2" type="QSU_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qspCO" type="QSP_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qspTS" type="QSP_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qspTS1" type="QSP_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qspTS2" type="QSP_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qspTS3" type="QSP_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qspTS4" type="QSP_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qspTS5" type="QSP_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qspRTO" type="QSP_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qspMO" type="QSP_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qspPQ" type="QSP_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qspPQ1" type="QSP_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qspREAL" type="QSP_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qspINT" type="QSP_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qspINT1" type="QSP_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qspINT2" type="QSP_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qssCO" type="QSS_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qssTS" type="QSS_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qssTS1" type="QSS_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qssTS2" type="QSS_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qssTS3" type="QSS_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qssTS4" type="QSS_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qssTS5" type="QSS_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qssRTO" type="QSS_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qssMO" type="QSS_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qssPQ" type="QSS_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qssPQ1" type="QSS_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qssREAL" type="QSS_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qssINT" type="QSS_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qssINT1" type="QSS_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qssINT2" type="QSS_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsCO" type="QSET_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsTS" type="QSET_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsTS1" type="QSET_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsTS2" type="QSET_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsTS3" type="QSET_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsTS4" type="QSET_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsTS5" type="QSET_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsRTO" type="QSET_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsMO" type="QSET_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsPQ" type="QSET_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsPQ1" type="QSET_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsREAL" type="QSET_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsINT" type="QSET_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsINT1" type="QSET_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qsINT2" type="QSET_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aPIVL" type="PIVL_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aPIVL1" type="PIVL_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aPIVL2" type="PIVL_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aPIVL3" type="PIVL_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aPIVL4" type="PIVL_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aPIVL5" type="PIVL_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aEIVL" type="EIVL_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aEIVL1" type="EIVL_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aEIVL2" type="EIVL_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aEIVL3" type="EIVL_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aEIVL4" type="EIVL_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="aEIVL5" type="EIVL_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nBL" type="NPPD_BL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nBL1" type="NPPD_BL.NONNULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nED" type="NPPD_ED" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nED1" type="NPPD_ED.IMAGE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nED2" type="NPPD_ED.TEXT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nED3" type="NPPD_ED.DOC" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nED4" type="NPPD_ED.DOC.REF" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nED5" type="NPPD_ED.DOC.INLINE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nED6" type="NPPD_ED.SIGNATURE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nED7" type="NPPD_ED.STRUCTUREDTEXT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nST" type="NPPD_ST" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nST1" type="NPPD_ST.NT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nSC" type="NPPD_SC" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nSC1" type="NPPD_SC.NT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nTEL" type="NPPD_TEL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nTEL1" type="NPPD_TEL.EMAIL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nTEL2" type="NPPD_TEL.PERSON" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nTEL3" type="NPPD_TEL.PHONE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nTEL4" type="NPPD_TEL.URL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nII" type="NPPD_II" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nCD" type="NPPD_CD" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nCV" type="NPPD_CD.CV" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nCO" type="NPPD_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nCS" type="NPPD_CS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nAD" type="NPPD_AD" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nEN" type="NPPD_EN" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nTN" type="NPPD_EN.TN" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nPN" type="NPPD_EN.PN" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nON" type="NPPD_EN.ON" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nTS" type="NPPD_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nTS1" type="NPPD_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nTS2" type="NPPD_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nTS3" type="NPPD_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nTS4" type="NPPD_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nTS5" type="NPPD_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nRTO" type="NPPD_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nMO" type="NPPD_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nPQ" type="NPPD_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nPQ1" type="NPPD_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nREAL" type="NPPD_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nINT" type="NPPD_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nINT1" type="NPPD_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="nINT2" type="NPPD_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="qBPIVL" type="QSET.BOUNDEDPIVL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hBL" type="HIST_BL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hBL1" type="HIST_BL.NONNULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hED" type="HIST_ED" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hED1" type="HIST_ED.IMAGE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hED2" type="HIST_ED.TEXT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hED3" type="HIST_ED.DOC" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hED4" type="HIST_ED.DOC.REF" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hED5" type="HIST_ED.DOC.INLINE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hED6" type="HIST_ED.SIGNATURE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hED7" type="HIST_ED.STRUCTUREDTEXT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hED8" type="HIST_ED.STRUCTUREDTITLE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hST" type="HIST_ST" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hST1" type="HIST_ST.NT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hSC" type="HIST_SC" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hSC1" type="HIST_SC.NT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hTEL" type="HIST_TEL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hTEL1" type="HIST_TEL.EMAIL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hTEL2" type="HIST_TEL.PERSON" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hTEL3" type="HIST_TEL.PHONE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hTEL4" type="HIST_TEL.URL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hII" type="HIST_II" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hCD" type="HIST_CD" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hCV" type="HIST_CD.CV" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hCO" type="HIST_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hCS" type="HIST_CS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hAD" type="HIST_AD" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hEN" type="HIST_EN" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hTN" type="HIST_EN.TN" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hPN" type="HIST_EN.PN" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hON" type="HIST_EN.ON" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hTS" type="HIST_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hTS1" type="HIST_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hTS2" type="HIST_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hTS3" type="HIST_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hTS4" type="HIST_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hTS5" type="HIST_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hRTO" type="HIST_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hMO" type="HIST_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hPQ" type="HIST_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hPQ1" type="HIST_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hREAL" type="HIST_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hINT" type="HIST_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hINT1" type="HIST_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="hINT2" type="HIST_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulCO" type="URG_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulTS" type="URG_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulTS1" type="URG_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulTS2" type="URG_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulTS3" type="URG_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulTS4" type="URG_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulTS5" type="URG_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulRTO" type="URG_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulMO" type="URG_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulPQ" type="URG_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulPQ1" type="URG_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulREAL" type="URG_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulINT" type="URG_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulINT1" type="URG_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulINT2" type="URG_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ullCO" type="URG.LOW_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ullTS" type="URG.LOW_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ullTS1" type="URG.LOW_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ullTS2" type="URG.LOW_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ullTS3" type="URG.LOW_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ullTS4" type="URG.LOW_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ullTS5" type="URG.LOW_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ullRTO" type="URG.LOW_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ullMO" type="URG.LOW_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ullPQ" type="URG.LOW_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ullPQ1" type="URG.LOW_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ullREAL" type="URG.LOW_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ullINT" type="URG.LOW_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ullINT1" type="URG.LOW_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ullINT2" type="URG.LOW_INT.POS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulhCO" type="URG.HIGH_CO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulhTS" type="URG.HIGH_TS" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulhTS1" type="URG.HIGH_TS.DATE" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulhTS2" type="URG.HIGH_TS.DATE.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulhTS3" type="URG.HIGH_TS.DATETIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulhTS4" type="URG.HIGH_TS.DATETIME.FULL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulhTS5" type="URG.HIGH_TS.BIRTH" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulhRTO" type="URG.HIGH_RTO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulhMO" type="URG.HIGH_MO" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulhPQ" type="URG.HIGH_PQ" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulhPQ1" type="URG.HIGH_PQ.TIME" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulhREAL" type="URG.HIGH_REAL" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulhINT" type="URG.HIGH_INT" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulhINT1" type="URG.HIGH_INT.NONNEG" minOccurs="0" maxOccurs="1" />
      <xsd:element name="ulhINT2" type="URG.HIGH_INT.POS" minOccurs="0" maxOccurs="1" />
    </xsd:sequence>
    <xsd:attribute name="e1" type="NullFlavor" use="optional" />
    <xsd:attribute name="e2" type="UpdateMode" use="optional" />
    <xsd:attribute name="e3" type="Compression" use="optional" />
    <xsd:attribute name="e4" type="IntegrityCheckAlgorithm" use="optional" />
    <xsd:attribute name="e5" type="set_TelecommunicationAddressUse" use="optional" />
    <xsd:attribute name="e6" type="IdentifierScope" use="optional" />
    <xsd:attribute name="e6a" type="IdentifierReliability" use="optional" />
    <xsd:attribute name="e7" type="AddressPartType" use="optional" />
    <xsd:attribute name="e8" type="set_PostalAddressUse" use="optional" />
    <xsd:attribute name="e9" type="EntityNamePartType" use="optional" />
    <xsd:attribute name="eA" type="set_EntityNamePartQualifier" use="optional" />
    <xsd:attribute name="eB" type="set_EntityNameUse" use="optional" />
    <xsd:attribute name="eC" type="CalendarCycle" use="optional" />
    <xsd:attribute name="eD" type="TimingEvent" use="optional" />
    <xsd:attribute name="eF" type="set_CodingRationale" use="optional" />
    <xsd:attribute name="eH" type="UncertaintyType" use="optional" />
    <xsd:attribute name="tUid" type="Uid" use="optional" />
    <xsd:attribute name="tUri" type="xsd:anyURI" use="optional" />
    <xsd:attribute name="tCode" type="Code" use="optional" />
  </xsd:complexType>
</xsd:schema>